---
slug: /link-flow/lb-enhancement/route-filter-service
---

import PaidCTA from '@site/src/components/PaidCTA';

# 路由过滤服务功能

本章节是及其重要的章节，可以说是 link-flow 的核心功能了！希望小伙伴能认真学习，体会到其中的设计精华所在。
经过之前的分析知道了路由过滤功能在此方法中开始执行
```java
public Flux<List<ServiceInstance>> get() {
    //获取所有的服务列表
    Flux<List<ServiceInstance>> listFlux = super.get();
    //从ThreadLocal获取参数
    Map<String, Object> parameterMap = BaseParameterHolder.getParameterMap();
    Map<String,Object> newMap = new HashMap<>(BaseParameterHolder.getParameterMap().size());
    newMap.putAll(parameterMap);
    System.out.println("第二处执行的线程；"+Thread.currentThread().getName());
    listFlux = listFlux.map(serviceInstances -> {
        System.out.println("第三处执行的线程；"+Thread.currentThread().getName());
        //到这里线程已经发生变化了，所以要把之前线程的将参数放入到ThreadLocal中，这样才能在后续的过滤器中获取到参数
        BaseParameterHolder.setParameterMap(newMap);
        List<ServiceInstance> allServers = new ArrayList<>();
        Optional.ofNullable(serviceInstances).ifPresent(allServers::addAll);
        //执行过滤器
        linkFlowFilterLoadBalance.selectServer(allServers);
        return allServers;
    });
    //返回结果
    return listFlux;
}
```
接下来开始真正的分析执行过滤功能的过程

# linkFlowFilterLoadBalance.selectServer(allServers)

首先 LinkFlowFilterLoadBalance 是接口，将过滤服务行为进行了抽象，这样是为了有新增的过滤功能，可以直接添加，保证了解耦性

```java
@LoadBalancerClients(defaultConfiguration = {WorkLoadBalancerClientConfiguration.class, ReactiveSupportConfiguration.class, BlockingSupportConfiguration.class})
public class WorkAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public LinkFlowFilterLoadBalance defaultLinkFlowFilterLoadBalance(List<AbstractServerFilter> strategyEnabledFilterList) {
        return new DefaultLinkFlowFilterLoadBalance(strategyEnabledFilterList);
    }
    //省略... ...
}
```

<PaidCTA />