---
slug: /link-flow/design/config-fetch-part1
---

import PaidCTA from '@site/src/components/PaidCTA';

# 配置中心数据的获取-上

在介绍 link-flow 项目时，提到了路由参数可以通过请求头传递规则，也可以通过配置中心来配置规则，而且配置中心修改更为灵活。
link-flow 支持的配置中心有 Nacos 和 Apollo，本章节详细介绍是如何读取配置中心的规则的

当引入 link-flow 后，会在项目启动时就会从配置中心读取数据，那这个启动后的时机是通过什么机制来实现呢？答案就是 Spring的事件机制，定义了一个自定义事件，当项目启动后发布此事件，而接听此事件的接收者就会知道项目启动了。

关于Spring事件机制的详细介绍可跳转到 技术精华讲解-Spring的事件发布与监听 章节。

## 自定义事件
这里自定义了一个事件叫 ConfigEvent
```java
public class ConfigEvent extends ApplicationEvent {
    /**
     * Create a new {@code ApplicationEvent}.
     *
     * @param source the object on which the event initially occurred or with
     * which the event is associated (never {@code null})
     */
    public ConfigEvent(final Object source) {
        super(source);
    }
}
```
## 事件发布者
事件定义好后，就要创建一个事件发布者 ConfigEventPush
```java
public class ConfigEventPush implements ApplicationListener<ApplicationStartedEvent> {
    
    @Override
    public void onApplicationEvent(final ApplicationStartedEvent event) {
        event.getApplicationContext().publishEvent(new ConfigEvent(this));
    }
}
```

这里能看到有点复杂，怎么监听事件又发布事件？首先监听的这个 ApplicationStartedEvent 事件，是SpringBoot 自带的，它是在 SpringBoot 启动后自己就会发布此事件了，我们要做的就是直接监听这个事件即可，这样当 SpringBoot 启动后，就会自动的执行到监听 ApplicationStartedEvent 事件的逻辑了。

当监听到后，再来发布我们自己自定义的 ConfigEvent 事件。这里可以通过 ApplicationStartedEvent 来拿到发布事件所用到的上下文 ApplicationContext。

# 事件接收者
```java
@AllArgsConstructor
@Slf4j
public class ConfigEventHandler implements ApplicationListener<ConfigEvent> {

    private final MetaDataOperation metaDataOperation;

    private final RemoteConfigRuleOperation remoteConfigRuleOperation;


    @Override
    public void onApplicationEvent(ConfigEvent event) {
        getConfig();
        remoteConfigRuleOperation.listenConfig();
    }
    //省略... ... 
}
```

<PaidCTA />