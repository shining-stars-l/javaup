---
slug: /link-flow/design/request-context-design
---

import PaidCTA from '@site/src/components/PaidCTA';

# 请求上下文的操作设计

在进行服务调用时，会根据配置好的路由参数，包括：区域、降级兜底区域、组、版本、降级兜底版本。这些参数可以通过请求头获取，也可以通过配置中心来获取。
而关于参数的获取也要进行分层设计，因为要考虑到 Gateway 服务和普通 Web服务

- Gateway服务中的请求头操作是 ServerHttpRequest 类型

- 普通Web服务中的请求头操作是 HttpServletRequest 类型

因为这两种是完全不相同的类型，所以从请求头获取数据的操作方式也是完全的不同，既然是要兼容 Gateway 服务和 Web服务，那么肯定首先要将获取参数的行为先设计好接口，叫 ContextConfigOperation

```java
public interface ContextConfigOperation {
    /**
     * 获取头名字
     * @return 值
     * */
    List<String> getHeaderNames();
    /**
     * 获取头值
     * @param name 名字
     * @return 值
     * */
    String getValueFromHeader(String name);
    /**
     * 获取标记
     * @return 值
     * */
    String fetchGray();
    /**
     * 获取版本
     * @return 值
     * */
    String fetchVersion();
    /**
     * 获取降级版本
     * @return 值
     * */
    String fetchDowngradesVersion();
    /**
     * 获取降级组
     * @return 值
     * */
    String fetchDowngradesZone();
    
    /**
     * 获取版本权重
     * @return 值
     * */
    String fetchVersionWeight();
}
```
接口是为了表示具有这些行为，对如果是具体实现的话，就再认真考虑了，虽然是要适配 Gateway服务 和 Web服务，要肯定有些操作不一样，而有些操作是一样的

就拿获取 版本 来说，在先从请求头中获取时，具体的Gateway服务 和 Web服务获取操作肯定是不一样，但从配置中心获取时，因为配置中心操作已经做了适配设计了，所以这个操作是一样的

## AbstractContextConfigOperation
所以对这种有的操作相同，有的操作又不相同的逻辑就会用到一种设计模式 模版模式 。而此模式最重要的就是要有个抽象类，将公共逻辑抽象出来，不同的逻辑要由各自实现类去实现。

<PaidCTA />