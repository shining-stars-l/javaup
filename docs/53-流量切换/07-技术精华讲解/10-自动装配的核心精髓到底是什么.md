---
slug: /link-flow/tech-highlights/autoconfigure-essentials
---

import PaidCTA from '@site/src/components/PaidCTA';

# 自动装配的核心精髓到底是什么

在 link-flow 中，通过 @AutoConfigureBefore 注解来实现让自己定义的配置先于原有的配置进行加载，如下：
```java
@AutoConfigureBefore(LoadBalancerClientConfiguration.class)
public class WorkLoadBalancerClientConfiguration {
    //省略
}
```
这样可以让 **WorkLoadBalancerClientConfiguration** 先于 **LoadBalancerClientConfiguration** 进行加载

关于 **@AutoConfigureBefore** 的介绍，可以跳转到 **技术精华讲解-@AutoConfigureBefore的作用** 的章节

而本章节将详细讲解 **@AutoConfigureBefore** 和自动装配的关系

## 案例1
```java

@Configuration
public class SchoolConfig {
    
    @ConditionalOnBean(Student.class)
    @Bean
    public School school(){
        System.out.println("school对象加载创建");
        return new School();
    }
}
```
```java
@Configuration
public class StudentConfig {
    
    @Bean
    public Student student(){
        System.out.println("student对象加载创建");
        return new Student();
    }
}
```
### 结果
```
student对象加载创建
```
发现只有student对象加载了，但school的加载条件是说当student对象存在时，school对象也会加载，现在并没有，那可能是普通配置类的问题，那就把它变成自动装配试试

## 案例2
```java
public class SchoolConfig {
    
    @ConditionalOnBean(Student.class)
    @Bean
    public School school(){
        System.out.println("school对象加载创建");
        return new School();
    }
}
```
```java
public class StudentConfig {
    
    @Bean
    public Student student(){
        System.out.println("student对象加载创建");
        return new Student();
    }
}
```
### 自动装配文件
```
com.example.config.SchoolConfig
com.example.config.StudentConfig
```
### 结果
```
student对象加载创建
```
发现还是只有student对象加载了，school对象还是没加载，这要怎么处理呢？

## beanDefinition
要先知道一个概念，Spring在创建对象时，不是直接就把对象创建出来，而是先获取创建对象的元信息(类名、构造方法、属性值等)包装成 **BeanDefinition** 结构，再放入一个 **beanDefinition** 类型的Map结构中，等把所有对象元信息都放入此map后，接着再遍历这个map，把真正的对象创建出来。
![](/img/link-flow/技术精华/beanDefinition.jpeg)

<PaidCTA />