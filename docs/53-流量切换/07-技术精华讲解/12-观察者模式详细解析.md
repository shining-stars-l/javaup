---
slug: /link-flow/tech-highlights/observer-pattern
---

import PaidCTA from '@site/src/components/PaidCTA';

# 观察者模式详细解析

## 1. 什么是观察者模式
观察者模式（Observer Pattern）是一种行为型设计模式，主要用于建立对象之间的一对多依赖关系。简单来说，当一个对象（**主题**或**被观察者**）的状态发生变化时，它会自动通知所有依赖它的对象（**观察者**），使得这些观察者能够做出相应的更新操作，而不需要紧密耦合到主题对象上。

这种模式非常适合用于事件驱动系统、消息订阅等场景。

---

## 2. 模式的组成角色
观察者模式主要包含以下几个角色：

+ **抽象主题（Subject）**  
  定义了添加、删除和通知观察者的方法，并维护一个观察者列表。
+ **具体主题（ConcreteSubject）**  
  实现了抽象主题的接口，封装了具体的状态变化逻辑。当状态变化时，会调用通知方法遍历所有观察者。
+ **抽象观察者（Observer）**  
  定义了更新接口（通常是一个 `update()` 方法），以便在主题发生变化时收到通知。
+ **具体观察者（ConcreteObserver）**  
  实现了抽象观察者的接口，在 `update()` 方法中定义如何根据主题状态的变化来做出相应的处理。

这种分离使得主题和观察者之间的耦合度降低，易于扩展和维护。

---

## 3. 工作流程
1. **注册观察者**  
   观察者向主题注册自己，以便在主题状态发生变化时能收到通知。
2. **状态改变**  
   当主题内部状态发生变化时，会调用通知方法（如 `notifyObservers()`），遍历内部保存的所有观察者。
3. **通知更新**  
   每个观察者的 `update()` 方法都会被调用，观察者根据接收到的状态或事件信息更新自己。

---

## 4. Java 代码示例
下面给出一个简单示例，展示如何用 Java 实现观察者模式：

### 4.1 定义观察者接口
```java
// 抽象观察者接口，定义了更新方法
public interface Observer {
    void update(int state);
}
```

### 4.2 定义主题接口和具体主题类
```java
// 抽象主题接口（也可以直接用抽象类）
public interface Subject {
    // 注册观察者
    void attach(Observer observer);   
    // 移除观察者
    void detach(Observer observer);
    // 通知所有观察者
    void notifyObservers();            
}

// 具体主题类
public class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    // 主题状态，可以是任意数据
    private int state;

    public int getState() {
        return state;
    }

    // 当设置新状态时，通知所有观察者
    public void setState(int state) {
        this.state = state;
        notifyObservers();
    }

    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        // 遍历所有观察者，调用其update方法
        for (Observer observer : observers) {
            observer.update(state);
        }
    }
}
```

### 4.3 定义具体观察者类
```java
// 具体观察者，观察者在更新时可以根据主题状态做出具体操作
public class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(int state) {
        System.out.println(name + " 收到通知，当前状态为：" + state);
    }
}
```

### 4.4 客户端测试代码
```java
public class ObserverPatternDemo {
    public static void main(String[] args) {
        // 创建主题对象
        ConcreteSubject subject = new ConcreteSubject();

        // 创建观察者，并注册到主题上
        Observer observer1 = new ConcreteObserver("观察者A");
        Observer observer2 = new ConcreteObserver("观察者B");
        subject.attach(observer1);
        subject.attach(observer2);

        // 改变主题状态，自动通知所有注册的观察者
        System.out.println("设置状态为 10");
        subject.setState(10);

        System.out.println("设置状态为 20");
        subject.setState(20);
    }
}
```

执行以上代码，输出结果类似于：

```plain
设置状态为 10
观察者A 收到通知，当前状态为：10
观察者B 收到通知，当前状态为：10
设置状态为 20
观察者A 收到通知，当前状态为：20
观察者B 收到通知，当前状态为：20
```

## 5. 优点与缺点
### 优点
+ **解耦**：主题与观察者之间通过抽象接口通信，不需要彼此了解内部实现，从而降低耦合性。
+ **动态扩展**：可以在运行时增加或删除观察者，灵活应对需求变化。
+ **符合开闭原则**：主题和观察者的修改不会互相影响，可以扩展新功能而无需修改原有代码。

### 缺点
+ **通知顺序**：如果观察者很多，通知过程可能顺序不确定，且如果其中一个观察者响应缓慢，可能会影响整体性能。
+ **内存泄漏风险**：如果未能及时移除不再需要的观察者，主题可能持有悬挂的引用，导致内存泄漏。
+ **复杂性**：对于简单场景，使用观察者模式可能会增加不必要的复杂性。

---

## 6. 应用场景
+ **GUI 事件处理**：按钮点击、鼠标移动等事件，可通过观察者模式通知多个组件。
+ **数据变化通知**：在 MVC 架构中，模型（Model）变化时自动通知视图（View）更新显示。
+ **消息订阅系统**：例如新闻订阅、社交媒体消息推送等场景。

---

## 7. 小结
观察者模式通过将“主题”（数据或状态的持有者）与“观察者”（对变化作出反应的对象）解耦，实现了灵活的动态通知机制。使用时需要注意正确管理观察者的注册与注销，避免性能问题或内存泄漏。无论是在桌面应用、Web 系统还是移动开发中，观察者模式都是一种非常有用的设计思想。
