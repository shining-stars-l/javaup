---
slug: /damai/basics/reset-data
---

# 如何对大麦网的数据进行重置

有的小伙伴在学习项目时，会进行多次支付，当次数很多了后，就会有节目的余票没有了，不能在进行支付的情况，为了解决这个问题，本人额外写了一个重置的接口，只要调用此接口，节目相关的所有数据就会进行重置为初始状态

## 接口地址
http://127.0.0.1:6085/damai/program/program/reset/execute

## 参数传递
### 请求头
```text
no_verify = true
```
### 请求体
```json
{
    "programId":"1"
}
```
这里把重置的流程代码也贴出来，如果小伙伴想知道如何进行重置的，也可以查看

## 重置流程
com.damai.controller.ProgramResetController#resetExecute
```java
@RestController
@RequestMapping("/program/reset")
@Api(tags = "program-reset", value = "节目数据重置")
public class ProgramResetController {
    
    @Autowired
    private ProgramService programService;
    
    @ApiOperation(value = "执行重置(根据节目id)")
    @PostMapping(value = "/execute")
    public ApiResponse<Boolean> resetExecute(@Valid @RequestBody ProgramResetExecuteDto programResetExecuteDto) {
        return ApiResponse.ok(programService.resetExecute(programResetExecuteDto));
    }
}
```
com.damai.service.ProgramService#resetExecute
```java
@Transactional(rollbackFor = Exception.class)
public Boolean resetExecute(ProgramResetExecuteDto programResetExecuteDto) {
    Long programId = programResetExecuteDto.getProgramId();
    //查出该节目下锁定和已售卖的座位
    LambdaQueryWrapper<Seat> seatQueryWrapper =
            Wrappers.lambdaQuery(Seat.class).eq(Seat::getProgramId, programId)
                    .in(Seat::getSellStatus,SellStatus.LOCK.getCode(),SellStatus.SOLD.getCode());
    List<Seat> seatList = seatMapper.selectList(seatQueryWrapper);
    if (CollectionUtil.isNotEmpty(seatList)) {
        //执行到这里说明有锁定和已售卖的座位，那么就把该节目下的座位都重置一遍
        LambdaUpdateWrapper<Seat> seatUpdateWrapper =
                Wrappers.lambdaUpdate(Seat.class).eq(Seat::getProgramId, programId);
        Seat seatUpdate = new Seat();
        seatUpdate.setSellStatus(SellStatus.NO_SOLD.getCode());
        seatMapper.update(seatUpdate,seatUpdateWrapper);
    }
    //查询该节目下的票档
    LambdaQueryWrapper<TicketCategory> ticketCategoryQueryWrapper =
            Wrappers.lambdaQuery(TicketCategory.class).eq(TicketCategory::getProgramId, programId);
    List<TicketCategory> ticketCategories = ticketCategoryMapper.selectList(ticketCategoryQueryWrapper);
    if (CollectionUtil.isNotEmpty(ticketCategories)) {
        for (TicketCategory ticketCategory : ticketCategories) {
            Long remainNumber = ticketCategory.getRemainNumber();
            Long totalNumber = ticketCategory.getTotalNumber();
            //如果总数和剩余数不一致，则进行重置
            if (!(remainNumber.equals(totalNumber))) {
                TicketCategory ticketCategoryUpdate = new TicketCategory();
                ticketCategoryUpdate.setRemainNumber(totalNumber);
                
                LambdaUpdateWrapper<TicketCategory> ticketCategoryUpdateWrapper =
                        Wrappers.lambdaUpdate(TicketCategory.class)
                                .eq(TicketCategory::getProgramId, programId)
                                .eq(TicketCategory::getId,ticketCategory.getId());
                ticketCategoryMapper.update(ticketCategoryUpdate,ticketCategoryUpdateWrapper);
            }
        }
    }
    //删除缓存相关数据
    delRedisData(programId);
    //删除本地缓存数据
    delLocalCache(programId);
    return true;
}
```
```java
private void delRedisData(Long programId){
    //删除节目缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM,programId));
    //删除节目演出时间缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SHOW_TIME,programId));
    //删除未售卖座位缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SEAT_NO_SOLD_HASH, programId));
    //删除锁定座位缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SEAT_LOCK_HASH, programId));
    //删除已售卖座位缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SEAT_SOLD_HASH, programId));
    //删除节目票档缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_TICKET_CATEGORY_LIST, programId));
    //删除余票缓存
    redisCache.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_TICKET_REMAIN_NUMBER_HASH, programId));
}
```
```java
public void delLocalCache(Long programId){
    log.info("删除本地缓存 programId : {}",programId);
    localCacheProgram.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM, programId).getRelKey());
    localCacheProgramGroup.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_GROUP, programId).getRelKey());
    localCacheProgramShowTime.del(RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SHOW_TIME, programId).getRelKey());
    localCacheTicketCategory.del(programId);
}
```