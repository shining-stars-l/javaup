---
slug: /damai/business/crypto/config
---

import PaidCTA from '@site/src/components/PaidCTA';

# 业务讲解-参数加解密配置

## 背景介绍

由于现在微服务项目基本都使用前后端分离，这样就会有暴漏接口参数的安全风险，而对于安全程度比较严格的项目来说，一般都是对参数进行加密，常见的有对称加密（如：AES）和非对称加密（如RSA）

## 加密算法介绍

### 对称加密

对称加密是最早的加密方法之一，其特点是加密和解密使用相同的密钥。这意味着，发送方和接收方必须提前共享密钥，且双方都必须保管好这个密钥，因为任何拥有密钥的人都能解密信息

### 工作原理

在对称加密中，数据被转换成不可读的格式（即密文），这一过程需要使用一个密钥及加密算法。接收方收到密文后，可以使用同一个密钥和对应的解密算法恢复原始数据



#### **优点**


+ 加解密速度快，适合大量数据的加密
+ 算法实现相对简单



#### **缺点**


+ 密钥的管理和分发是一个挑战，尤其是在需要安全通信的多方之间
+ 如果密钥被泄露，数据的安全性将无法保障



### 非对称加密


非对称加密，也称为公钥加密，是一种加密方法，其中使用一对密钥：公钥和私钥。公钥可以公开分享，用于加密数据；而私钥必须保密，用于解密数据



#### 工作原理


发送方使用接收方的公钥对数据进行加密，然后发送给接收方。由于只有接收方持有匹配的私钥，因此只有接收方能解密这些数据。此外，非对称加密还可以用于数字签名，确保数据完整性和发送方身份的验证



#### 优点


+ 解决了对称加密中密钥分发的问题
+ 可以用于加密和数字签名，提供更全面的安全保障



#### 缺点


+ 相比对称加密，非对称加密的加解密过程更耗时，不适合大量数据的加密
+ 需要更复杂的算法和更长的密钥



## 项目接口参数的加解密


大麦项目是选择真实项目中的加密方法，选择的是RSA的非对称加密



+  前端负责将接口加密
+  后端负责解密此项目设计的RSA中的公私钥是可以调用接口来存储到数据库中进行存储配置的，接口详情查看ApiFox的`base-data`模块  

+  不同平台渠道的RSA公私钥是不同的，比如小程序、公众号、客户端。不同的类型采用不同的公私钥



```sql
CREATE TABLE `channel_data` (
  `id` bigint(64) NOT NULL COMMENT 'id',
  `name` varchar(50) DEFAULT NULL COMMENT '名称',
  `code` varchar(50) NOT NULL COMMENT '编码',
  `introduce` varchar(500) DEFAULT NULL COMMENT '介绍描述',
  `sign_public_key` text NOT NULL COMMENT 'rsa签名公钥',
  `sign_secret_key` text NOT NULL COMMENT 'rsa签名秘钥',
  `aes_key` text COMMENT 'aes秘钥',
  `data_public_key` text COMMENT 'rsa参数公钥',
  `data_secret_key` text COMMENT 'rsa参数私钥',
  `token_secret` text NOT NULL COMMENT 'token秘钥',
  `status` int(1) DEFAULT '1' COMMENT '状态 1:启用 0:禁用',
  `edit_time` datetime DEFAULT NULL COMMENT '编辑时间',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `code_IDX` (`code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='渠道基础数据信息';
```

`code` 就是不同的平台，比如小程序、公众号、客户端。

## 步骤

后端添加 `channel_data` 相关数据后，保存到数据库中后，也会保存到redis缓存中，这样用于网关查询时提高效率

com.damai.service.ChannelDataService#add 
```java
@Transactional(rollbackFor = Exception.class)
public void add(ChannelDataAddDto channelDataAddDto) {
    ChannelData channelData = new ChannelData();
    BeanUtils.copyProperties(channelDataAddDto,channelData);
    channelData.setId(uidGenerator.getUid());
    channelData.setCreateTime(DateUtils.now());
    channelDataMapper.insert(channelData);
    addRedisChannelData(channelData);
}
/**
* 保存到redis中
*/
private void addRedisChannelData(ChannelData channelData){
    GetChannelDataVo getChannelDataVo = new GetChannelDataVo();
    BeanUtils.copyProperties(channelData,getChannelDataVo);
    redisCache.set(RedisKeyWrap.createRedisKey(RedisKeyEnum.CHANNEL_DATA,getChannelDataVo.getCode()),getChannelDataVo);
}
```

到这里将基础参数的结构介绍完毕，关于具体的加解密过程在下一章节详细讲解



