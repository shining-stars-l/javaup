---
slug: /hmdp-plus/tech-essentials/lock-and-transaction-issues
---

import PaidCTA from '@site/src/components/PaidCTA';

# 深入剖析分布式锁与事务在生产中的“疑难杂症”

:::info plus 版本专属
此章节是黑马点评 Plus 版本中专有的内容，而在整套文档中将普通版本和 Plus 版本都融合在了一起，让大家更方便的学习。
:::

这里是使用了 **Redssion**，并在其基础上进行了封装以及使用自定义注解，并且结合了Spring的环绕切面来实现分布式锁的功能

## 代码示例
```java
@RequestMapping("insertNumber/{number}/{id}")
public boolean insertNumber(@PathVariable Long number,@PathVariable Long id){
    return testService.insertNumber(number,id);
}
```

```java
@Transactional
@ServiceLock(name = "insertNumber",keys = {"#id"},waitTime = 50)
public boolean insertNumber(final Long number, final Long id) {
    Test test = testMapper.getById(id);
    Long originalNumber = test.getNumber();
    originalNumber = originalNumber + number;
    test.setNumber(originalNumber);
    testMapper.updateById(test);
    return true;
}
```



逻辑很简单，根据id查出test对象后，在原有基础上增加number值，然后更新到数据库中。

### 锁的切面
```java
@Aspect
public class ServiceLockAspect {

    @Around("@annotation(servicelock)")
    public Object around(ProceedingJoinPoint joinPoint, ServiceLock servicelock) throws Throwable {
        //解析出加锁的键
        String lockName = (joinPoint,servicelock);
        //进行加锁
        boolean reuslt = lock.lock(lockName);
        //如果加锁成功
        if (reuslt) {
            try {
                //执行业务逻辑
                return joinPoint.proceed();
            }finally{
                //解锁
                lock.unlock(lockName);
            }
        }else {
            //等待或者执行加锁失败的处理逻辑
        }
    }
}
```

## 问题
在实际压测中发现并不能保证数据的正确性，比如设置一秒内发出1000个请求，参数number为1，正确结果应该是1000，但实际结果要比1000小

这是一个很细节的问题，在分布式锁的方法级别使用上也会存在，网上关于分布式的实例和课程有很多，但几乎都没有说到这个问题，这体现出了项目到底是不是真实性的，因为生产中会复现出非常多的细节问题，黑马点评 plus 项目也是讲这些细节都会讲解到，让小伙伴真正的掌握，体现的就是**真实性**

## 分析

<PaidCTA />