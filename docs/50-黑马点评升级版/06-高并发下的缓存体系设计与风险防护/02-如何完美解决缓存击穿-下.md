---
slug: /hmdp-plus/cache-architecture/cache-breakdown-part2
---

import PaidCTA from '@site/src/components/PaidCTA';

# 如何完美解决缓存击穿-下

:::info plus 版本专属
此章节是黑马点评 Plus 版本中专有的内容，而在整套文档中将普通版本和 Plus 版本都融合在了一起，让大家更方便的学习。
:::

建议小伙伴先跳转到相应文档学习什么是缓存击穿？

[如何完美解决缓存击穿-上](/hmdp-plus/cache-architecture/cache-breakdown-part1)


在上述的文档说，使用了分布式锁的方式来解决缓存击穿，最后留下了问题，这段代码哪里可以进行优化？这里我们再来分析下这段代码

```java
public String getDataV2(String id){
    RedisTemplate<String,String> redisTemplate = redisCache.getInstance();
    String cachedValue = redisTemplate.opsForValue().get(id);
    if (StringUtil.isEmpty(cachedValue)) {
        RLock lock = serviceLockTool.getLock(LockType.Reentrant, id);
        lock.lock();
        try {
            Program program = programMapper.selectById(id);
            if (Objects.nonNull(program)) {
                redisTemplate.opsForValue().set(id,JSON.toJSONString(program));
                cachedValue = JSON.toJSONString(program);
            }
        } finally {
            lock.unlock();
        }
    }
    return cachedValue;
}
```

这里面其实存在查询的问题，每个请求确实是串行执行了，但每个请求获得锁之后还是去查询数据库了，其实完全没有必要都去查询数据库的，当第一个请求从数据库查询出来放入缓存后，之后的请求都应该从缓存中查询才对，那要怎么样才能够实现呢？

## 双重检测锁的单例模式
大家在学习单例模式的使用，应该都知道 **双重检测锁** 这种方式

```java
public class DCLSingleton {

    // 单例
    private static volatile DCLSingleton singleton = null;

    // 私有构造方法
    private DCLSingleton() {
    }

    public static DCLSingleton getInstance() {
        if (null == singleton) {
            synchronized (DCLSingleton.class) {
                if (null == singleton) {
                    singleton = new  DCLSingleton();
                }
            }
        }
        return singleton;
    }
}
```

先是判断对象是否为空，如果为空的话，则加锁，在锁的逻辑中再判断一次对象是否为空，如果还是为空的话，则进行创建对象

我们就可以利用这种双重检测的方式，来对其进行优化

## 分布式锁+双重检测的方案

<PaidCTA />