---
slug: /hmdp-plus/cache-architecture/multi-level-cache
---

import PaidCTA from '@site/src/components/PaidCTA';

# 百万并发的终极杀招 "多级缓存"

:::info plus 版本专属
此章节是黑马点评 Plus 版本中专有的内容，而在整套文档中将普通版本和 Plus 版本都融合在了一起，让大家更方便的学习。
:::

在上章节，讲解了项目中通过利用 **双重判断 + 缓存空值 + 分布式锁 + 布隆过滤器** 组合的方案来解决缓存击穿和穿透的问题。

但是当并发足够高的时候，Redis的性能也会支撑不了的，有的人可能会说 可以使用Redis的集群架构啊，这样不就能把数据分散到不同的节点上而从降低压力了吗

这种使用Redis集群的方案其实要分情况来考虑的

1. 比如说100W个并发请求，查询100个优惠券，每1W个请求查询同一个优惠券，这种查询不同的优惠券，使用集群确实可以的
2. 还是100W个并发请求，查询同一个优惠券，这100W个请求仍然会落到同一个Redis节点上，使用集群仍然解决不了

## 思考
但什么样的缓存比Redis的性能还要高？

大道至简，其实就是JVM的内存本地缓存，本地缓存的性能可是比Redis高出了几十倍不止，并且也不存在网络性能损耗，抗住百万并发是没什么问题的

但引入了本地缓存要思考的问题就很多了，比如 如何设计本地缓存？如何管理本地缓存、Redis缓存这种多层级的缓存、本地缓存要怎么考虑容量和过期时间来避免内存溢出的问题？

## 一、本地缓存的引入
所以这里我们要引用本地缓存来解决高并发的压力，原因有这几点：

1. 使用JVM的内存作为本地缓存，其效率是Reids的几十倍以上
2. 使用本地缓存不存在网络性能损耗

### 1.1 引入本地缓存要考虑的问题
1. 如何设计本地缓存？
2. 如何管理本地缓存、Redis缓存这种多层级的缓存？
3. 本地缓存要怎么考虑容量和过期时间来避免内存溢出的问题？
4. 缓存一致性要怎么解决？多实例情况怎么解决？

### 1.2 本地缓存 **Caffeine**
#### 1.2.1 Caffeine 是什么
+ Caffeine 是基于 Java 的高性能本地缓存库，采用哈希结构与基于访问频次的 Window TinyLFU 策略，命中率高、延迟低。
+ 内建丰富策略：容量限制、基于时间/权重的过期、异步刷新、统计监控等，可通过流式 API 组合使用。
+ 相比 Guava Cache，Caffeine 在并发性能、命中率和可配置性上全面升级，成为 JVM 场景的事实标准本地缓存实现。

#### 1.2.2 Caffeine 的核心特性
1. **高命中率策略**：Window TinyLFU 同时考虑近期访问和历史访问权重，兼顾冷热数据。
2. **多样化过期机制**：支持固定 TTL、基于写入/访问/自定义逻辑的动态过期。
3. **异步能力**：与 `CompletableFuture` 配合处理缓存穿透导致的 I/O 延迟。
4. **线程安全**：内部使用无锁算法和分段结构，提供高吞吐的并发访问。
5. **可观测性**：提供命中率、加载耗时等监控指标，方便调优。

#### 1.2.3 官方地址：
[GitHub - ben-manes/caffeine: A high performance caching library for Java](https://github.com/ben-manes/caffeine)

## **二、Caffeine 缓存的使用**
而在本章节，要引入本地缓存 **Caffeine**，和 Redis 缓存共同组合成“多极缓存”的功能，在解决缓存击穿和缓存穿透的前提下，来进一步提高项目中的吞吐量。

### 2.1 优惠券本地缓存的代码实现

<PaidCTA />