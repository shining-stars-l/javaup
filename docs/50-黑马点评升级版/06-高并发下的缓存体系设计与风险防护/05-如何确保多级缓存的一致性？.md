---
slug: /hmdp-plus/cache-architecture/multi-level-consistency
---

import PaidCTA from '@site/src/components/PaidCTA';

# 如何确保多级缓存的一致性？

:::info plus 版本专属
此章节是黑马点评 Plus 版本中专有的内容，而在整套文档中将普通版本和 Plus 版本都融合在了一起，让大家更方便的学习。
:::

在讲解多级缓存章节中，我们介绍了如何引入本地缓存，以及和 Redis 缓存进行配合，建议没看过的小伙伴，先去学习这一章节

[百万并发的终极杀招 "多级缓存"](/hmdp-plus/cache-architecture/multi-level-cache)


而本文的重点是来介绍如果有修改的操作，那该如何去解决缓存一致性呢？又比如缓存中数据都是根据秒杀优惠券结束时间来设置的，如果遇到了突发情况，要求优惠券提前下线，要如何在缓存中提前过期呢？

## 一、思考
对于这种一致性问题，可以使用通用的方案，也就是当修改数据库中的数据后，将对应的缓存清空，Redis的缓存好办，可以直接删除掉

#### 但是本地缓存就会有个问题，如果存在多实例，那么要怎么处理？
假设线上部署了5个实例节点，经过一段时间运行后，每个实例都有了自己的本地缓存，那么如果进行了数据的修改操作后，就要将这5个实例节点的数据都清空

那么要如何通知这5个节点呢？可以有这几种方式：

1. **定时任务查询：** 定时从库中扫描失效的数据，对于已经失效的数据就在缓存中删除。这种只能应对简单而且数据量小的业务，而且不好估算定时任务的执行时间，频率高了对数据库的压力很大，频率低了缓存又不及时被清除，而且假如某段时间没有修改数据或者主动要失效的操作，那么就白执行了。而且这种多实例的情况，就只能每个实例都要查询一遍数据库，属实没有必要
2. **使用MQ消息中间件(Kafka、RocketMQ、RabbitMQ)：** 这种方式确实是可以，但是要思考如果之前没有引入MQ的话有没有必要为了这个功能特意来引入
3. **Redis的PUB/SUB，订阅/发布模式：** 这种发布订阅模式有个致命的问题就是没有办法进行持久化的，如果出现网络断开、Redis宕机的话，消息就会丢失，这种也不是很推荐
4. **Redis的Stream：** 可以理解成是Redis对消息队列MQ的完善实现，支持分组消费和广播消费，并且可以将消息进行持久化


在之前的大麦项目中，是使用了RedisStream来让本地缓存进行失效，而为了让大家可以学习更多不同的解决方案，这次我们使用MQ，由于项目中的 MQ 是使用了 Kafka，所以来使用 Kafka 进行处理本地缓存。

## 二、修改优惠券的流程

<PaidCTA />