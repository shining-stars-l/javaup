---
slug: /java/tomcat/classloader
description: "WebApp ClassLoader实现多应用类隔离;Bootstrap/System/Common/WebApp四层类加载器结构;WEB-INF/classes与WEB-INF/lib加载路径;双亲委派机制改造解决版本冲突。"
keywords: ["类加载器", "WebApp ClassLoader", "双亲委派", "类隔离", "热部署"]
sidebar_class_name: has-paid-badge
---

import PaidCTA from '@site/src/components/PaidCTA';

# Tomcat类加载器与类加载机制

## 概述

Tomcat作为一个支持多Web应用同时运行的Servlet容器，需要解决一个核心问题：**如何实现不同Web应用之间的类隔离**。为此，Tomcat设计了一套独特的类加载器层次结构，并对传统的双亲委派机制进行了改造。

## 为什么需要特殊的类加载机制

在深入了解Tomcat类加载机制之前，先理解其设计背景：

### 多应用隔离需求

```mermaid
flowchart TB
    subgraph Tomcat容器
        subgraph 应用A
            A1[Spring 4.x]
            A2[MyApp-1.0.jar]
        end
        subgraph 应用B
            B1[Spring 5.x]
            B2[MyApp-2.0.jar]
        end
        subgraph 应用C
            C1[Spring 6.x]
            C2[MyApp-3.0.jar]
        end
    end
    
    style A1 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,rx:10
    style B1 fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,rx:10
    style C1 fill:#fce4ec,stroke:#c2185b,stroke-width:2px,rx:10
```

**面临的问题：**

| 问题 | 描述 | 传统方式的困境 |
|------|------|----------------|
| 版本冲突 | 不同应用依赖同一类库的不同版本 | 双亲委派只会加载一个版本 |
| 类污染 | 一个应用的类影响其他应用 | 共享类加载器导致相互影响 |
| 热部署 | 更新某个应用不影响其他应用 | 类加载器不支持卸载类 |

## Tomcat类加载器层次结构

### 完整层次结构图

```mermaid
flowchart TB
    subgraph JVM层
        A[Bootstrap ClassLoader<br/>加载JRE核心类]
    end
    
    subgraph 扩展层
        B[Extension ClassLoader<br/>加载JRE扩展类]
    end
    
    subgraph Tomcat层
        C[System ClassLoader<br/>加载Tomcat启动类]
        D[Common ClassLoader<br/>加载公共类库]
    end
    
    subgraph 可选层
        E[Server ClassLoader<br/>服务器私有类]
        F[Shared ClassLoader<br/>应用共享类]
    end
    
    subgraph 应用层
        G[WebApp ClassLoader 1<br/>应用A的类]
        H[WebApp ClassLoader 2<br/>应用B的类]
        I[WebApp ClassLoader N<br/>应用N的类]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    D --> F
    E --> G
    F --> G
    E --> H
    F --> H
    E --> I
    F --> I
    
    style A fill:#ffebee,stroke:#c62828,stroke-width:2px,rx:10
    style B fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,rx:10
    style C fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,rx:10
    style D fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,rx:10
    style E fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,rx:10
    style F fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,rx:10
    style G fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
    style H fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
    style I fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
```

### 核心类加载器说明

#### Bootstrap ClassLoader（启动类加载器）

由JVM实现，负责加载Java核心类库：

- **加载路径**：`$JAVA_HOME/lib` 及 `lib/ext`
- **加载内容**：`java.lang.*`、`java.util.*` 等核心类
- **特点**：由C++实现，在Java中表现为null

#### System ClassLoader（系统类加载器）

负责加载Tomcat启动所需的类：

- **加载路径**：`$CATALINA_HOME/bin`
- **加载内容**：
  - `bootstrap.jar` - 启动入口类
  - `tomcat-juli.jar` - 日志组件
  - `commons-daemon.jar` - 守护进程支持

#### Common ClassLoader（公共类加载器）

加载Tomcat和所有Web应用都可以访问的公共类：

- **加载路径**：`$CATALINA_HOME/lib`
- **加载内容**：
  - `servlet-api.jar` - Servlet规范API
  - `jsp-api.jar` - JSP规范API
  - `catalina.jar` - Tomcat核心
  - 其他公共库

#### WebApp ClassLoader（Web应用类加载器）

每个Web应用独立拥有的类加载器：

- **加载路径**：
  - `WEB-INF/classes` - 应用编译的类
  - `WEB-INF/lib` - 应用依赖的jar包
- **特点**：应用间完全隔离

### 简化的实际层次

在默认配置下，Server ClassLoader和Shared ClassLoader是未启用的，实际的类加载器层次更加简洁：

```mermaid
flowchart TB
    A[Bootstrap ClassLoader] --> B[System ClassLoader]
    B --> C[Common ClassLoader]
    C --> D[WebApp ClassLoader 1]
    C --> E[WebApp ClassLoader 2]
    C --> F[WebApp ClassLoader N]
    
    style A fill:#ffebee,stroke:#c62828,stroke-width:2px,rx:10
    style B fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,rx:10
    style C fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,rx:10
    style D fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
    style E fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
    style F fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,rx:10
```

## 类加载机制详解

Tomcat的类加载机制并非简单地遵循或违反双亲委派，而是采用了一种灵活的策略。

<PaidCTA />