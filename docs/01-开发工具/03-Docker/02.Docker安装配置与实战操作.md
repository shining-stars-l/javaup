---
slug: /tools/docker/practical-guide
title: Docker 安装配置与实战操作
---

## Docker环境搭建

在开始使用Docker之前,需要根据操作系统选择合适的安装方式。Docker提供了跨平台支持,可以在Windows、macOS和各类Linux发行版上运行。

### Windows系统安装

Windows环境下推荐使用Docker Desktop,它提供了图形化管理界面和完整的容器运行环境。

**系统要求**
- Windows 10 64位专业版/企业版/教育版
- 开启Hyper-V虚拟化功能
- 或使用WSL 2(Windows子系统Linux版本2)

**安装步骤**

访问Docker官网下载Docker Desktop for Windows安装包。安装前需要启用Hyper-V:

1. 打开控制面板 → 程序 → 启用或关闭Windows功能
2. 勾选"Hyper-V"和"容器"选项
3. 重启计算机使配置生效
4. 运行Docker Desktop安装程序
5. 启动Docker Desktop,等待引擎初始化完成

验证安装:

```bash
# 查看Docker版本
docker version

# 运行测试容器
docker run hello-world
```

### macOS系统安装

macOS用户同样使用Docker Desktop,安装过程更为简洁。

**使用Homebrew安装(推荐)**

```bash
# 通过Homebrew Cask安装
brew install --cask docker

# 启动Docker应用程序
open /Applications/Docker.app
```

**手动安装**

1. 从Docker官网下载Docker Desktop for Mac的dmg文件
2. 双击dmg文件,将Docker拖入Applications文件夹
3. 从应用程序启动Docker
4. 首次启动需要输入系统密码授权

验证安装:

```bash
# 检查Docker状态
docker info

# 查看系统信息
docker system info
```

### Linux系统安装

Linux环境下推荐使用官方脚本进行安装,以CentOS/RHEL为例:

**使用官方脚本快速安装**

```bash
# 下载安装脚本
curl -fsSL https://get.docker.com -o get-docker.sh

# 使用阿里云镜像加速安装
sh get-docker.sh --mirror Aliyun

# 启动Docker服务
systemctl start docker

# 设置开机自启
systemctl enable docker

# 验证安装
docker --version
```

**Ubuntu/Debian手动安装**

```bash
# 更新包索引
sudo apt-get update

# 安装依赖包
sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# 添加Docker官方GPG密钥
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
  sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

# 设置仓库
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 安装Docker Engine
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io
```

**配置非root用户权限**

```bash
# 创建docker用户组
sudo groupadd docker

# 将当前用户加入docker组
sudo usermod -aG docker $USER

# 重新登录使配置生效
newgrp docker

# 验证无需sudo即可运行
docker run hello-world
```

### 配置镜像加速器

由于Docker Hub服务器位于海外,国内访问速度较慢。配置镜像加速器可以显著提升镜像拉取速度。

**阿里云镜像加速器配置**

1. 登录阿里云容器镜像服务控制台
2. 左侧菜单选择"镜像加速器"
3. 复制专属加速器地址

Linux系统配置:

```bash
# 创建或编辑daemon配置文件
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": [
    "https://你的加速器地址.mirror.aliyuncs.com"
  ]
}
EOF

# 重新加载配置
sudo systemctl daemon-reload

# 重启Docker服务
sudo systemctl restart docker

# 验证配置
docker info | grep -A 1 "Registry Mirrors"
```

Windows/macOS配置:

在Docker Desktop设置中找到"Docker Engine",编辑JSON配置添加镜像地址。

```mermaid
graph LR
    Pull([拉取镜像请求]) --> Check{是否配置<br/>加速器?}
    Check -->|未配置| Hub([Docker Hub<br/>海外服务器])
    Check -->|已配置| Mirror([国内镜像站])
    
    Hub --> Slow([下载缓慢])
    Mirror --> Fast([高速下载])
    
    Fast --> Local([本地镜像库])
    Slow --> Local
    
    classDef slowStyle fill:#E85D75,stroke:none,color:#fff
    classDef fastStyle fill:#50C878,stroke:none,color:#fff
    classDef normalStyle fill:#4A90E2,stroke:none,color:#fff
    
    class Hub,Slow slowStyle
    class Mirror,Fast fastStyle
    class Pull,Check,Local normalStyle
```

## 镜像管理实战

Docker镜像是容器运行的基础,掌握镜像的查询、拉取、构建和管理操作至关重要。

### 搜索和拉取镜像

**搜索镜像**

可以通过Docker Hub网站或命令行搜索所需镜像:

```bash
# 搜索Redis相关镜像
docker search redis

# 限制搜索结果数量
docker search --limit 5 redis

# 仅显示官方镜像
docker search --filter is-official=true redis
```

搜索结果说明:
- NAME: 镜像名称
- DESCRIPTION: 镜像描述
- STARS: 收藏数量
- OFFICIAL: 是否为官方镜像
- AUTOMATED: 是否为自动构建

**拉取镜像**

```bash
# 拉取最新版本
docker pull redis

# 拉取指定版本
docker pull redis:7.0

# 拉取指定平台镜像
docker pull --platform linux/arm64 redis:7.0

# 从私有仓库拉取
docker pull registry.company.com/project/myapp:v1.0
```

拉取进度说明:

```bash
7.0: Pulling from library/redis
# 每一行代表一个镜像层的下载进度
a2abf6c4d29d: Pull complete
c7a4e4382001: Pull complete
4044b9ba67c9: Pull complete
c8388a79482f: Pull complete
413c8bb60be2: Pull complete
1abfd3011519: Pull complete
```

### 查看和管理本地镜像

**列出镜像**

```bash
# 查看所有镜像
docker images

# 查看特定镜像
docker images redis

# 仅显示镜像ID
docker images -q

# 显示包括中间层在内的所有镜像
docker images -a

# 格式化输出
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

**镜像详细信息**

```bash
# 查看镜像详细信息
docker inspect redis:7.0

# 查看镜像的构建历史
docker history redis:7.0

# 查看镜像的层信息
docker image inspect --format '{{.RootFS.Layers}}' redis:7.0
```

### 镜像标签管理

镜像标签(Tag)用于区分同一镜像的不同版本:

```bash
# 为现有镜像创建新标签
docker tag redis:7.0 myregistry.com/redis:v7.0

# 创建多个标签
docker tag redis:7.0 myredis:latest
docker tag redis:7.0 myredis:stable

# 查看同一镜像的多个标签
docker images | grep redis
```

### 删除镜像

```bash
# 通过镜像名和标签删除
docker rmi redis:7.0

# 通过镜像ID删除
docker rmi abc123def456

# 强制删除(即使有容器在使用)
docker rmi -f redis:7.0

# 删除所有未使用的镜像
docker image prune

# 删除所有镜像(包括使用中的)
docker rmi -f $(docker images -aq)
```

删除技巧:

```bash
# 删除特定仓库的所有镜像
docker rmi $(docker images 'myapp' -aq)

# 删除无标签的悬空镜像
docker image prune -a

# 删除指定时间前创建的镜像
docker image prune -a --filter "until=24h"
```

### 保存和加载镜像

当需要在没有网络的环境部署或备份镜像时,可以将镜像导出为文件:

**导出镜像**

```bash
# 导出单个镜像
docker save -o redis-7.0.tar redis:7.0

# 导出多个镜像到一个文件
docker save -o myimages.tar redis:7.0 nginx:1.23 postgres:14

# 使用管道压缩
docker save redis:7.0 | gzip > redis-7.0.tar.gz
```

**加载镜像**

```bash
# 从tar文件加载镜像
docker load -i redis-7.0.tar

# 从压缩文件加载
gunzip -c redis-7.0.tar.gz | docker load

# 加载后验证
docker images redis
```

```mermaid
graph TB
    Build([构建镜像]) --> Local([本地镜像仓库])
    Pull([拉取镜像]) --> Local
    
    Local --> Tag([打标签])
    Local --> Push([推送到远程])
    Local --> Save([导出为文件])
    
    Tag --> Push
    Save --> Transfer([文件传输])
    Transfer --> Load([加载镜像])
    Load --> Remote([远程服务器])
    
    classDef inputStyle fill:#4A90E2,stroke:none,color:#fff
    classDef localStyle fill:#9B59B6,stroke:none,color:#fff
    classDef outputStyle fill:#50C878,stroke:none,color:#fff
    
    class Build,Pull inputStyle
    class Local,Tag localStyle
    class Push,Save,Transfer,Load,Remote outputStyle
```

## 容器运行与管理

容器是Docker的核心,理解容器的生命周期管理是掌握Docker的关键。

### 创建和启动容器

**基础运行命令**

```bash
# 运行容器(前台模式)
docker run nginx:1.23

# 后台运行容器
docker run -d nginx:1.23

# 运行并命名容器
docker run -d --name web-server nginx:1.23

# 端口映射
docker run -d -p 8080:80 --name web nginx:1.23

# 多端口映射
docker run -d \
  -p 8080:80 \
  -p 8443:443 \
  --name web nginx:1.23

# 随机端口映射
docker run -d -P nginx:1.23
```

**环境变量配置**

```bash
# 设置单个环境变量
docker run -d \
  -e MYSQL_ROOT_PASSWORD=secret123 \
  mysql:8.0

# 设置多个环境变量
docker run -d \
  -e POSTGRES_USER=admin \
  -e POSTGRES_PASSWORD=pass123 \
  -e POSTGRES_DB=mydb \
  postgres:14

# 从文件读取环境变量
docker run -d --env-file ./env.list myapp:latest
```

env.list文件示例:

```bash
# 数据库配置
DB_HOST=localhost
DB_PORT=5432
DB_NAME=production

# 应用配置
APP_ENV=production
APP_DEBUG=false
```

### 容器生命周期管理

**查看容器状态**

```bash
# 查看运行中的容器
docker ps

# 查看所有容器(包括已停止)
docker ps -a

# 仅显示容器ID
docker ps -q

# 自定义输出格式
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

# 查看最近创建的容器
docker ps -n 5
```

**容器控制命令**

```bash
# 停止容器(发送SIGTERM信号,10秒后SIGKILL)
docker stop web-server

# 强制停止(立即发送SIGKILL)
docker kill web-server

# 启动已停止的容器
docker start web-server

# 重启容器
docker restart web-server

# 暂停容器(冻结进程)
docker pause web-server

# 恢复暂停的容器
docker unpause web-server
```

**删除容器**

```bash
# 删除已停止的容器
docker rm web-server

# 强制删除运行中的容器
docker rm -f web-server

# 删除所有已停止的容器
docker container prune

# 删除所有容器(包括运行中)
docker rm -f $(docker ps -aq)
```

### 容器交互操作

**查看容器日志**

```bash
# 查看容器日志
docker logs web-server

# 实时跟踪日志
docker logs -f web-server

# 显示时间戳
docker logs -t web-server

# 查看最近100行日志
docker logs --tail 100 web-server

# 查看指定时间段的日志
docker logs --since 2024-01-01T00:00:00 web-server
docker logs --since 30m web-server
```

**进入容器内部**

```bash
# 以交互模式进入容器
docker exec -it web-server bash

# 执行单个命令
docker exec web-server ls /app

# 以root用户进入
docker exec -it -u root web-server bash

# 在容器中执行脚本
docker exec web-server sh -c "cd /app && ./deploy.sh"
```

容器内常用操作:

```bash
# 进入容器后
ls -la                    # 查看文件
ps aux                    # 查看进程
cat /etc/os-release      # 查看系统信息
netstat -tlnp            # 查看端口监听
exit                      # 退出容器
```

**文件拷贝**

```bash
# 从宿主机复制到容器
docker cp ./config.json web-server:/app/config.json

# 从容器复制到宿主机
docker cp web-server:/var/log/app.log ./logs/

# 复制整个目录
docker cp ./dist web-server:/usr/share/nginx/html/
```

实际应用示例:

```bash
# 部署前端应用到Nginx容器
# 1. 构建前端项目
npm run build

# 2. 启动Nginx容器
docker run -d -p 80:80 --name frontend nginx:1.23

# 3. 复制构建产物到容器
docker cp ./dist/. frontend:/usr/share/nginx/html/

# 4. 重启Nginx使配置生效
docker exec frontend nginx -s reload

# 5. 验证部署
curl http://localhost
```

### 容器资源限制

合理限制容器资源使用,防止单个容器占用过多资源:

**CPU限制**

```bash
# 限制CPU份额(相对权重)
docker run -d --cpu-shares=512 myapp:latest

# 限制CPU核心数
docker run -d --cpus="1.5" myapp:latest

# 指定CPU核心
docker run -d --cpuset-cpus="0,1" myapp:latest
```

**内存限制**

```bash
# 限制内存使用
docker run -d --memory="1g" myapp:latest

# 限制内存+Swap
docker run -d \
  --memory="1g" \
  --memory-swap="2g" \
  myapp:latest

# 禁用Swap
docker run -d \
  --memory="1g" \
  --memory-swap="1g" \
  myapp:latest
```

**磁盘IO限制**

```bash
# 限制读写速度(字节/秒)
docker run -d \
  --device-read-bps /dev/sda:10mb \
  --device-write-bps /dev/sda:10mb \
  myapp:latest
```

**综合资源限制示例**

```bash
# 生产环境数据库容器
docker run -d \
  --name prod-database \
  --cpus="2.0" \
  --memory="4g" \
  --memory-swap="4g" \
  -p 5432:5432 \
  -v db-data:/var/lib/postgresql/data \
  -e POSTGRES_PASSWORD=secret \
  --restart=unless-stopped \
  postgres:14
```

### 容器网络管理

**查看网络**

```bash
# 列出所有网络
docker network ls

# 查看网络详情
docker network inspect bridge

# 查看容器的网络配置
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web-server
```

**创建自定义网络**

```bash
# 创建桥接网络
docker network create app-network

# 创建指定子网的网络
docker network create --subnet=172.20.0.0/16 app-network

# 在自定义网络中运行容器
docker run -d \
  --name web \
  --network app-network \
  nginx:1.23

# 将已有容器连接到网络
docker network connect app-network database
```

**容器间通信**

```bash
# 启动数据库容器
docker run -d \
  --name postgres-db \
  --network app-network \
  postgres:14

# 启动应用容器,通过服务名访问数据库
docker run -d \
  --name backend \
  --network app-network \
  -e DATABASE_URL=postgresql://postgres-db:5432/mydb \
  myapp:latest
```

```mermaid
graph TB
    Host([宿主机])
    
    Host --> Network([Docker网络])
    
    Network --> Container1([Web容器<br/>:80])
    Network --> Container2([API容器<br/>:8080])
    Network --> Container3([数据库容器<br/>:5432])
    
    Container1 -.通过服务名通信.-> Container2
    Container2 -.通过服务名通信.-> Container3
    
    Host -.端口映射.-> Container1
    
    classDef hostStyle fill:#34495E,stroke:none,color:#fff
    classDef netStyle fill:#3498DB,stroke:none,color:#fff
    classDef containerStyle fill:#2ECC71,stroke:none,color:#fff
    
    class Host hostStyle
    class Network netStyle
    class Container1,Container2,Container3 containerStyle
```

## 数据持久化方案

容器的设计理念是无状态和临时性的,但实际应用中常需要持久化存储数据。Docker提供了数据卷和挂载目录两种方案。

### 数据卷(Volume)

数据卷是Docker管理的持久化存储区域,推荐用于生产环境:

**创建和管理数据卷**

```bash
# 创建命名数据卷
docker volume create app-data

# 查看所有数据卷
docker volume ls

# 查看数据卷详情
docker volume inspect app-data

# 删除未使用的数据卷
docker volume prune

# 删除指定数据卷
docker volume rm app-data
```

**使用数据卷**

```bash
# 挂载数据卷到容器
docker run -d \
  --name db \
  -v app-data:/var/lib/postgresql/data \
  postgres:14

# 多个容器共享数据卷
docker run -d --name backup -v app-data:/backup ubuntu
```

### 绑定挂载(Bind Mount)

将宿主机目录直接挂载到容器,适合开发环境:

```bash
# 挂载宿主机目录
docker run -d \
  --name web \
  -v /home/user/web:/usr/share/nginx/html \
  nginx:1.23

# 只读挂载
docker run -d \
  --name web \
  -v /home/user/web:/usr/share/nginx/html:ro \
  nginx:1.23

# 使用绝对路径或PWD变量
docker run -d \
  -v $(pwd)/src:/app/src \
  myapp:latest
```

### 数据备份与恢复

**备份数据卷**

```bash
# 使用临时容器备份数据卷
docker run --rm \
  -v app-data:/source \
  -v $(pwd):/backup \
  ubuntu tar czf /backup/backup.tar.gz -C /source .
```

**恢复数据卷**

```bash
# 创建新的数据卷
docker volume create app-data-restored

# 从备份文件恢复
docker run --rm \
  -v app-data-restored:/target \
  -v $(pwd):/backup \
  ubuntu tar xzf /backup/backup.tar.gz -C /target
```

### 实战案例:搭建完整的Web应用

部署一个包含前端、后端和数据库的完整应用:

```bash
# 1. 创建自定义网络
docker network create webapp-net

# 2. 启动PostgreSQL数据库
docker run -d \
  --name postgres \
  --network webapp-net \
  -v postgres-data:/var/lib/postgresql/data \
  -e POSTGRES_PASSWORD=dbpass123 \
  -e POSTGRES_DB=webapp \
  postgres:14

# 3. 启动后端API服务
docker run -d \
  --name api-server \
  --network webapp-net \
  -e DATABASE_URL=postgresql://postgres:dbpass123@postgres:5432/webapp \
  -e JWT_SECRET=mysecret \
  --restart=unless-stopped \
  myapi:1.0

# 4. 启动Nginx前端服务
docker run -d \
  --name frontend \
  --network webapp-net \
  -p 80:80 \
  -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf:ro \
  nginx:1.23

# 5. 验证服务
docker ps
curl http://localhost
```

Docker为应用的容器化运行提供了完整的工具链,从环境搭建到容器管理,再到数据持久化,构建了现代化的应用部署体系。
