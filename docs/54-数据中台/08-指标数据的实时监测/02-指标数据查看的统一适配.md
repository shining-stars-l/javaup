---
slug: /dock-data-center/metric/adaptive
---

import PaidCTA from '@site/src/components/PaidCTA';

# 指标数据查看的统一适配
在上一篇章节中，讲解了在实时查询采集后的指标数据功能时，时间查询时不同时间维度的执行流程。而本篇章节，将讲解如何查询指标数据

# API入口

```java
@Operation(summary  = "查询指标数据")
@PostMapping(value = "/data/query")
public ApiResponse<ReportVo> dataQuery(@Valid @RequestBody QueryGatherDataDto queryDataDto) {
    return ApiResponse.ok(collectService.dataQuery(queryDataDto));
}
```

# QueryGatherDataDto入参结构

```java
@Data
@Schema(title="QueryGatherDataDto", description ="QueryGatherDataDto")
public class QueryGatherDataDto {
    
    @Schema(name ="ruleId", type ="Long",description="规则id",requiredMode= RequiredMode.REQUIRED)
    @NotNull
    private Long ruleId;
    
    @Schema(name ="videoTypeId", type ="Integer",description="视频分类id",requiredMode= RequiredMode.REQUIRED)
    @NotNull
    private Integer videoTypeId;
    
    @Schema(name ="dateType", type ="Long",description="日期类型",requiredMode= RequiredMode.REQUIRED)
    @NotNull
    private Integer dateType;
    
    @Schema(name ="startTime", type ="Date",description="开始时间",requiredMode= RequiredMode.REQUIRED)
    @JsonFormat(pattern = "yyyy-MM-dd")
    @NotNull
    private Date startTime;
    
    @Schema(name ="endTime", type ="Date",description="结束时间",requiredMode= RequiredMode.REQUIRED)
    @JsonFormat(pattern = "yyyy-MM-dd")
    @NotNull
    private Date endTime;
}
```

方法接收一个`QueryGatherDataDto`对象，包含以下关键字段：

- `ruleId`：规则ID，用于确定查询规则
- `videoTypeId`：视频分类ID，指定要查询的视频分类
- `dateType`：日期类型（1-天，2-周，3-月，4-年）
- `startTime`：开始时间
- `endTime`：结束时间

参数并不是很多，但是可以把所有视频分类和不同时间的维度都可以查询，有此可见此流程的扩展性是非常高的

# 指标数据查询

```java
public ReportVo dataQuery(QueryGatherDataDto queryGatherDataDto){
    ReportVo reportVo = new ReportVo();
    QueryGatherDataVo queryGatherDataVo = new QueryGatherDataVo();
    //日期类型
    DateType dateType = Optional.ofNullable(DateType.getRc(queryGatherDataDto.getDateType()))
            .orElseThrow(() -> new DockDataCenterFrameException("Invalid date type: " + queryGatherDataDto.getDateType()));
    //获取维度信息
    DimensionGather dimensionGather = dimensionGatherService.getDimensionByRuleIdAndTableName(queryGatherDataDto.getRuleId(),
            TableName.VIDEO_TYPE.getValue());
    if (Objects.isNull(dimensionGather)) {
        return reportVo;
    }
    Map<String, Object> params = Map.of(SqlParameterConstant.VIDEO_TYPE_ID, queryGatherDataDto.getVideoTypeId());
    //从库中查询视频类型
    List<VideoType> videoTypeList = agilityDataHandler.list(dimensionGather.getCollectDetail(),
            dimensionGather.getCollectSourceName(), VideoType.class, params);
    if (CollectionUtil.isEmpty(videoTypeList)) {
        return reportVo;
    }
    VideoType videoType = videoTypeList.get(0);

    //视频维度
    VideoDimensionType videoDimensionType = Optional.ofNullable(VideoDimensionType.getByCode(videoType.getCategoryLevel()))
            .orElseThrow(() -> new DockDataCenterFrameException(BaseCode.VIDEO_DIMENSION_TYPE_NOT_EXIST));
    //根据传入的视频维度进行降级
    //如果传入是parent_video_type，那么统计的就是这个parent_video_type下所有的video_type
    //如果传入是video_type，那么统计的就是这个video_type下所有的video
    //所以将传入视频维度进行降一级进行查询统计
    VideoDimensionType downVideoDimensionType = VideoDimensionFunc.downGradeVideoDimension(videoDimensionType);
    //构建查询需要的参数
    QueryDataTransfers queryDataTransfers = getQueryDataTransfers(queryGatherDataDto, downVideoDimensionType, dateType);
    QueryDataExecuteTransfers queryDataExecuteTransfers = new QueryDataExecuteTransfers();
    queryDataExecuteTransfers.setAccumulateColumnName(videoType.getName());
    queryDataTransfers.setQueryDataExecuteTransfers(queryDataExecuteTransfers);

    ParamTransfers paramTransfers = new ParamTransfers();
    paramTransfers.setRuleId(queryGatherDataDto.getRuleId());
    paramTransfers.setRuleType(RuleType.QUERY);
    paramTransfers.setQueryDataTransfers(queryDataTransfers);

    RuleHandleOutput ruleHandleOutput = ruleHandler.handle(paramTransfers);
    if (Objects.isNull(ruleHandleOutput.getReportVo())) {
        return reportVo;
    }
    reportVo = ruleHandleOutput.getReportVo();
    reportVo.setTotal(Optional.ofNullable(reportVo.getRowDataVoList()).map(List::size).orElseGet(()->0));
    return reportVo;
}
```

## 详细执行流程

### 第一阶段：初始化和参数验证

```java
public ReportVo dataQuery(QueryGatherDataDto queryGatherDataDto){
    ReportVo reportVo = new ReportVo();
    QueryGatherDataVo queryGatherDataVo = new QueryGatherDataVo();
```

方法开始时创建了两个核心对象：
- `ReportVo`：最终返回的报表数据对象
- `QueryGatherDataVo`：查询数据视图对象（在当前实现中未使用）

### 第二阶段：日期类型解析和验证

```java
DateType dateType = Optional.ofNullable(DateType.getRc(queryGatherDataDto.getDateType()))
        .orElseThrow(() -> new DockDataCenterFrameException("Invalid date type: " + queryGatherDataDto.getDateType()));
```

1. 通过`DateType.getRc()`方法将整数类型的日期类型转换为枚举对象
2. `DateType`枚举包含四种类型：
   - `DAY(1,"day","天")`
   - `WEEK(2,"week","周")`
   - `MONTH(3,"month","月")`
   - `YEAR(4,"year","年")`
3. 如果日期类型无效，抛出`DockDataCenterFrameException`异常

### 第三阶段：维度信息获取

```java
DimensionGather dimensionGather = dimensionGatherService.getDimensionByRuleIdAndTableName(queryGatherDataDto.getRuleId(),
        TableName.VIDEO_TYPE.getValue());
if (Objects.isNull(dimensionGather)) {
    return reportVo;
}
```

1. 根据规则ID和表名（`VIDEO_TYPE`）查询维度采集配置
2. `DimensionGather`实体包含：
   - `collectType`：采集方式（1-SQL查询，2-接口调用）
   - `collectDetail`：具体的采集实现（SQL脚本或URL）
   - `collectSourceName`：数据源名称
   - `tableName`：表名
3. 如果找不到维度配置，直接返回空的报表对象

### 第四阶段：视频类型数据查询
<PaidCTA />