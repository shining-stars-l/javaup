---
slug: /dock-data-center/metric/detail/1
---

import PaidCTA from '@site/src/components/PaidCTA';

# 指标数据查看的细节分析（上）
在上一篇章节中，讲解了查询指标数据的总体过程，其中`QueryDataHandler`查询数据的处理器的执行过程是整个核心重点，本章节将详细讲解此流程

# 查询数据的处理器

org.javaup.handler.core.data.impl.QueryDataHandler#dataHandle

```java
public RuleHandleOutput dataHandle(TotalParamTransfers totalParamTransfers){
    //获取查询需要的参数
    QueryDataTransfers queryDataTransfers = totalParamTransfers.getParamTransfers().getQueryDataTransfers();
    //视频维度
    VideoDimensionType videoDimensionType = queryDataTransfers.getVideoDimensionType();

    if (Objects.isNull(videoDimensionType)) {
        throw new DockDataCenterFrameException(BaseCode.VIDEO_DIMENSION_TYPE_NOT_EXIST);
    }
    //根据视频维度和表格类型获取对应的查询器
    DataFetchExecutor dataFetchExecutor = dataFetchExecutorContext.getResultServiceHandler(
            videoDimensionType.getCode());
    if (Objects.isNull(dataFetchExecutor)) {
        throw new DockDataCenterFrameException(BaseCode.VIDEO_DIMENSION_TYPE_IMPL_NOT_EXIST);
    }
    return dataFetchExecutor.execute(totalParamTransfers);
}
```

这里的重点是`DataFetchExecutor dataFetchExecutor = dataFetchExecutorContext.getResultServiceHandler(videoDimensionType.getCode())`

依旧还是熟悉的策略模式

## 数据获取执行器的定义

首先要定义数据获取执行器的行为，包括：获取类型、执行数据获取

```java
public interface DataFetchExecutor{
    
    /**
     * 获取类型
     * @return 类型
     */
    Integer getType();
    
    /**
     * 执行数据获取
     * @param totalParamTransfers 参数传输对象
     * @return 规则处理输出对象
     */
    RuleHandleOutput execute(TotalParamTransfers totalParamTransfers);

}
```

## 数据获取执行器的上下文

依旧要有上下文容器，将所有`DataFetchExecutor`的实现策略，放到容器中

```java
@Component
public class DataFetchExecutorContext {

    @Autowired
    private List<DataFetchExecutor> dataFetchExecutorList;
    
    private Map<Integer, DataFetchExecutor> resultServiceHandlerMap;
    
    @PostConstruct
    public void init(){
        resultServiceHandlerMap = dataFetchExecutorList.stream().collect(Collectors.toMap(DataFetchExecutor::getType,
                r -> r, (v1, v2) -> v2));
    }
    
    public DataFetchExecutor getResultServiceHandler(Integer type){
        return resultServiceHandlerMap.get(type);
    }
}
```

利用了Spring的加载bean的方式，当服务启动后，会执行Spring中的`@PostConstruct`修饰的方法`init`，获取所有`DataFetchExecutor`类型的`dataFetchExecutorList`集合

接着将此集合转成`resultServiceHandlerMap`也就是Map结构，key: 执行类型, value: 数据获取执行器

提供了`getResultServiceHandler`能够根据`type`执行类型从`resultServiceHandlerMap`获取具体的数据获取执行器

`DataFetchExecutor`的实现有：

- **VideoReportDataFetchExecutor：** 视频报表数据获取执行器
- **VideoTypeReportDataFetchExecutor：** 视频类型报表数据获取执行器
- **ParentVideoTypeReportDataFetchExecutor：** 父视频类型报表数据获取执行器

# 视频报表数据获取执行器

视频报表数据获取执行器此执行器是这三种数据获取执行器的基础，逻辑也是最为复杂，把它弄清楚了，其他两种也自然很好理解了

- **视频报表数据获取执行器**、**视频类型报表数据获取执行器**、**父视频类型报表数据获取执行器** 是三种策略
- 而这三种策略父类都是抽象类`AbstractReportDataFetchExecutor`

也就是说这里既用到了策略模式，也用到了模板模式，所以当分析 **视频报表数据获取执行器（VideoReportDataFetchExecutor）** 执行流程时，肯定要把它的模板父类`AbstractReportDataFetchExecutor`也要关联上，一起分析才可以。

下面就开始具体的执行流程

<PaidCTA />