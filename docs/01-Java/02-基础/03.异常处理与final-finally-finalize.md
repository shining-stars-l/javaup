---
slug: /java/base/exceptions-final
title: 异常处理与 final/finally/finalize
---

# 异常处理与 final/finally/finalize

## 异常处理

### final、finally、finalize 的区别

final、finally 和 finalize 是 Java 中三个完全不同的概念,它们之间没有直接关系,只是名称相似容易混淆。

#### final 关键字

**作用**:用于声明常量、防止继承或方法重写

final 可以修饰变量、方法和类:

**1. final 变量**:一旦赋值后不可修改,即常量

```java
public class FinalVariableDemo {
    // final 成员变量必须初始化
    private final int MAX_SIZE = 100;
    
    // final 静态常量
    public static final String APP_NAME = "MyApp";
    
    public void test() {
        // final 局部变量
        final int count = 10;
        // count = 20;  // 编译错误:无法修改 final 变量
        
        // final 引用变量:引用不可变,但对象内容可变
        final List<String> list = new ArrayList<>();
        list.add("Hello");  // 可以修改对象内容
        // list = new ArrayList<>();  // 编译错误:不能修改引用
    }
}
```

**2. final 方法**:不能被子类重写

```java
public class Parent {
    // final 方法不能被重写
    public final void show() {
        System.out.println("这个方法不能被重写");
    }
}

public class Child extends Parent {
    // @Override
    // public void show() {  // 编译错误:不能重写 final 方法
    //     System.out.println("尝试重写");
    // }
}
```

**3. final 类**:不能被继承

```java
// final 类不能被继承
public final class FinalClass {
    // String、Integer 等包装类都是 final 类
}

// public class SubClass extends FinalClass {  // 编译错误:不能继承 final 类
// }
```

#### finally 关键字

**作用**:异常处理的一部分,用于确保代码块总是执行

finally 与 try-catch 配合使用,通常用于资源清理:

```java
public void readFile(String path) {
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(path);
        // 读取文件内容
        int data = fis.read();
        System.out.println(data);
    } catch (IOException e) {
        System.err.println("读取文件失败: " + e.getMessage());
    } finally {
        // 无论是否发生异常,finally 块都会执行
        // 通常用于关闭资源
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**finally 的执行时机**:
- try 块正常执行完毕后执行 finally
- catch 块捕获异常后执行 finally
- try 或 catch 中有 return 语句,在 return 前执行 finally
- 某些特殊情况下 finally 可能不执行(如 System.exit()、JVM 崩溃等)

#### finalize 方法

**作用**:对象被垃圾回收前的清理方法

finalize 是 Object 类的一个方法,在对象被垃圾回收器回收前调用:

```java
public class FinalizeDemo {
    @Override
    protected void finalize() throws Throwable {
        try {
            // 在对象被回收前执行清理操作
            System.out.println("对象即将被回收");
            // 释放资源,如关闭文件、数据库连接等
        } finally {
            super.finalize();
        }
    }
}
```

**为什么不推荐使用 finalize**:

1. **调用时机不确定**:无法保证何时被调用,甚至可能不被调用
2. **性能开销大**:会影响垃圾回收效率
3. **可能导致对象复活**:finalize 中可以让对象重新被引用
4. **从 Java 9 开始已被废弃**:推荐使用 try-with-resources 或 Cleaner API

```java
// 不推荐:使用 finalize
public class OldWay {
    private FileInputStream fis;
    
    @Override
    protected void finalize() throws Throwable {
        if (fis != null) {
            fis.close();
        }
    }
}

// 推荐:使用 try-with-resources
public class NewWay {
    public void readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path)) {
            // 使用文件流
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 自动关闭,无需 finalize
    }
}
```

#### 三者对比总结

| 特性 | final | finally | finalize |
|------|------|---------|----------|
| **类型** | 关键字 | 关键字 | 方法 |
| **用途** | 声明常量/防止继承或重写 | 异常处理,确保代码执行 | 对象回收前的清理 |
| **修饰对象** | 变量、方法、类 | try-catch 语句块 | Object 类的方法 |
| **是否推荐** | 推荐使用 | 推荐使用 | 不推荐(已废弃) |
| **执行时机** | 编译时确定 | 异常处理时执行 | 垃圾回收时可能执行 |

```mermaid
graph TB
    subgraph final关键字
        F1[final 变量<br/>常量]
        F2[final 方法<br/>不可重写]
        F3[final 类<br/>不可继承]
    end
    
    subgraph finally关键字
        FL1[try-catch-finally]
        FL2[确保代码执行]
        FL3[资源清理]
    end
    
    subgraph finalize方法
        FZ1[Object.finalize]
        FZ2[垃圾回收前调用]
        FZ3[已废弃,不推荐]
    end
```

### 异常类层次结构

```mermaid
graph TB
    Throwable([Throwable<br/>异常基类])
    
    Throwable --> Exception([Exception<br/>可处理异常])
    Throwable --> Error([Error<br/>系统错误])
    
    Exception --> Checked([Checked Exception<br/>受检查异常])
    Exception --> Unchecked([Unchecked Exception<br/>RuntimeException])
    
    Checked --> IOException([IOException])
    Checked --> SQLException([SQLException])
    Checked --> ClassNotFound([ClassNotFoundException])
    
    Unchecked --> NPE([NullPointerException])
    Unchecked --> ArrayIndex([ArrayIndexOutOfBounds])
    Unchecked --> Arithmetic([ArithmeticException])
    Unchecked --> ClassCast([ClassCastException])
    
    Error --> OOM([OutOfMemoryError])
    Error --> StackOverflow([StackOverflowError])
    Error --> NoClassDef([NoClassDefFoundError])
    
    classDef baseStyle fill:#4A90E2,stroke:none,color:#fff
    classDef exceptionStyle fill:#9B59B6,stroke:none,color:#fff
    classDef errorStyle fill:#E74C3C,stroke:none,color:#fff
    classDef checkedStyle fill:#3498DB,stroke:none,color:#fff
    classDef uncheckedStyle fill:#E67E22,stroke:none,color:#fff
    
    class Throwable baseStyle
    class Exception exceptionStyle
    class Error errorStyle
    class Checked,IOException,SQLException,ClassNotFound checkedStyle
    class Unchecked,NPE,ArrayIndex,Arithmetic,ClassCast uncheckedStyle
    class OOM,StackOverflow,NoClassDef errorStyle
```

所有异常的共同祖先是 `Throwable`,分为两大类:

**1. Exception(可处理异常)**
- **Checked Exception**(受检查异常):编译时必须处理
  - IOException
  - SQLException  
  - ClassNotFoundException

- **Unchecked Exception**(非受检查异常):编译时可不处理
  - RuntimeException 及其子类
  - NullPointerException
  - ArrayIndexOutOfBoundsException
  - ArithmeticException

**2. Error(系统错误)**
- JVM 运行错误,程序无法处理
- OutOfMemoryError
- StackOverflowError
- NoClassDefFoundError

### Exception 与 Error 的差异

```java
// Exception:可以捕获并处理
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("除数不能为 0");
}

// Error:不建议捕获,应该避免发生
public class StackOverflowDemo {
    public static void main(String[] args) {
        recursion();  // 递归无出口,最终导致 StackOverflowError
    }
    
    public static void recursion() {
        recursion();
    }
}
```

### Checked Exception 与 Unchecked Exception

**Checked Exception(受检查异常)**:编译器强制要求处理

```java
// 必须处理,否则编译不通过
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);  // 可能抛 FileNotFoundException
    // ...
}

// 处理方式 1: try-catch
public void method1() {
    try {
        readFile("test.txt");
    } catch (IOException e) {
        e.printStackTrace();
    }
}

// 处理方式 2: throws 声明
public void method2() throws IOException {
    readFile("test.txt");
}
```

**Unchecked Exception(非受检查异常)**:编译器不强制处理

```java
// RuntimeException 及其子类,可以不处理
public int divide(int a, int b) {
    return a / b;  // 可能抛 ArithmeticException,但编译通过
}

public String getName(User user) {
    return user.getName();  // 可能抛 NullPointerException
}

// 常见的 RuntimeException
public class CommonExceptions {
    public static void main(String[] args) {
        // 1. NullPointerException
        String str = null;
        // str.length();  // NPE
        
        // 2. ArrayIndexOutOfBoundsException
        int[] arr = {1, 2, 3};
        // int x = arr[5];  // 数组越界
        
        // 3. ClassCastException
        Object obj = "Hello";
        // Integer num = (Integer) obj;  // 类型转换异常
        
        // 4. NumberFormatException
        // int num = Integer.parseInt("abc");  // 数字格式异常
        
        // 5. IllegalArgumentException
        // setAge(-5);  // 参数非法
    }
    
    public static void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("年龄不能为负数");
        }
    }
}
```

### 异常处理最佳实践

默认使用 **Unchecked Exception**,只在必要时用 Checked Exception:

```java
// 推荐:用 RuntimeException 表示代码 Bug
public class UserService {
    public User findById(Long id) {
        if (id == null) {
            throw new IllegalArgumentException("ID 不能为 null");  // 非受检查
        }
        // ...
        return null;
    }
}

// 只在业务逻辑必须处理时用 Checked Exception
public class PaymentService {
    // 余额不足是正常业务分支,强制调用者处理
    public void pay(double amount) throws InsufficientBalanceException {
        if (balance < amount) {
            throw new InsufficientBalanceException("余额不足");
        }
        // 执行支付
    }
}
```

### try-catch-finally 用法

```java
try {
    // 可能抛异常的代码
    int result = riskyOperation();
    System.out.println("结果:" + result);
} catch (SpecificException e) {
    // 处理特定异常
    System.out.println("处理特定异常:" + e.getMessage());
} catch (Exception e) {
    // 处理其他异常
    System.out.println("处理通用异常:" + e.getMessage());
} finally {
    // 无论是否发生异常,都会执行
    // 通常用于资源清理
    System.out.println("清理资源");
}
```

**注意**:不要在 finally 中使用 return,会屏蔽 try 中的 return

```java
public int badExample() {
    try {
        return 1;
    } finally {
        return 2;  // 不好!将覆盖 try 中的返回值
    }
}

// 返回 2,而不是 1
```

### finally 一定会执行吗?

**大多数情况下会**,但有例外:

```java
// 1. System.exit() 终止 JVM
try {
    System.exit(0);  // JVM 退出,finally 不执行
} finally {
    System.out.println("不会执行");
}

// 2. 线程被 kill
Thread.currentThread().stop();  // 强制停止线程

// 3. CPU 关闭
// 无法模拟...
```

### try-with-resources 用法

Java 7 引入,自动关闭资源:

```java
// 传统方式:手动关闭资源
Scanner scanner = null;
try {
    scanner = new Scanner(new File("test.txt"));
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();  // 手动关闭
    }
}

// try-with-resources:自动关闭
try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
// 自动调用 scanner.close()

// 多个资源
try (BufferedReader br = new BufferedReader(new FileReader("input.txt"));
     BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        bw.write(line);
        bw.newLine();
    }
}
```

**适用条件**:资源必须实现 `AutoCloseable` 或 `Closeable` 接口。

### 异常使用注意事项

```java
// 1. 不要将异常定义为静态变量
public class BadExample {
    private static final Exception EXCEPTION = new Exception("错误");  // 错误!
    
    public void method() throws Exception {
        throw EXCEPTION;  // 所有地方抛同一个异常,堆栈信息不准
    }
}

// 2. 抛出更具体的异常
public class GoodExample {
    public void parseInt(String str) {
        if (!str.matches("\\d+")) {
            throw new NumberFormatException("无效数字:" + str);  // 具体异常
        }
    }
}

// 3. 避免重复记录日志
public class LogExample {
    public void process() {
        try {
            riskyOperation();
        } catch (Exception e) {
            log.error("操作失败", e);  // 已经记录日志
            throw e;  // 再次抛出时不要再记录
        }
    }
}

/ 4. 异常信息要有意义
throw new Exception("错误");  // 不好
throw new Exception("用户名不能为空");  // 好
```

### 为什么不建议使用异常控制业务流程

在《Effective Java》一书中,作者明确指出:**不应该使用异常来控制常规的业务流程**。异常机制是为处理非预期的错误情况而设计的,将其用于正常的业务逻辑控制会带来诸多问题。

#### 什么是用异常控制业务流程

简单来说,就是将异常作为程序的正常执行路径,而不是仅仅用于处理错误情况。

**典型的错误示例**:使用异常处理数据验证

```java
// 不推荐:使用异常控制业务流程
public class UserService {
    public User createUser(String username, String email) {
        try {
            // 尝试创建用户
            User user = new User(username, email);
            return userRepository.save(user);
        } catch (IllegalArgumentException e) {
            // 捕获参数校验异常来控制业务流程
            log.warn("用户创建失败: {}", e.getMessage());
            return null;
        }
    }
}

// 推荐:使用条件判断
public class UserService {
    public User createUser(String username, String email) {
        // 先进行业务校验
        if (username == null || username.isEmpty()) {
            log.warn("用户名不能为空");
            return null;
        }
        if (email == null || !email.contains("@")) {
            log.warn("邮箱格式不正确");
            return null;
        }
        
        // 正常创建用户
        User user = new User(username, email);
        return userRepository.save(user);
    }
}
```

#### 使用异常控制业务流程的问题

**1. 严重的性能问题**

异常的创建和处理开销非常大,主要体现在:

```java
public class PerformanceTest {
    public static void main(String[] args) {
        int iterations = 100000;
        
        // 测试1:使用异常控制流程
        long start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            try {
                throw new Exception("测试异常");
            } catch (Exception e) {
                // 捕获并继续
            }
        }
        System.out.println("异常方式耗时: " + (System.currentTimeMillis() - start) + "ms");
        
        // 测试2:使用条件判断
        start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            if (false) {
                // 条件不满足
            }
        }
        System.out.println("判断方式耗时: " + (System.currentTimeMillis() - start) + "ms");
    }
}
// 输出结果:
// 异常方式耗时: 约 2000-3000ms
// 判断方式耗时: 约 1-2ms
```

**性能差异的原因**:
- 创建异常对象需要填充完整的调用栈信息(StackTrace)
- 异常的抛出和捕获涉及 JVM 的栈展开(Stack Unwinding)机制
- 频繁的异常处理会影响 JIT 编译器的优化

**2. 违背异常设计的初衷**

Java 异常机制的设计目的是处理**非预期的错误情况**,而不是作为控制流程的工具:

```java
// 错误示例:用异常控制循环退出
public class BadLoop {
    public void processArray(String[] array) {
        try {
            int i = 0;
            while (true) {
                System.out.println(array[i]);
                i++;
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // 用异常来跳出循环
        }
    }
}

// 正确做法:使用循环条件
public class GoodLoop {
    public void processArray(String[] array) {
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
}
```

这样的代码会:
- 降低代码的可读性和可维护性
- 让其他开发者难以理解代码的真实意图
- 违背"代码即文档"的最佳实践

**3. 影响事务的正确回滚**

在涉及数据库事务的场景中,异常被捕获可能导致事务无法正常回滚:

```java
@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    // 错误示例:异常被捕获导致事务无法回滚
    @Transactional
    public void createOrder(Order order) {
        // 保存订单
        orderRepository.save(order);
        
        try {
            // 扣减库存
            inventoryService.deductStock(order.getProductId(), order.getQuantity());
        } catch (InsufficientStockException e) {
            // 异常被捕获,事务不会回滚
            // 导致订单已保存,但库存扣减失败
            log.error("库存不足", e);
            return;
        }
        
        // 其他业务逻辑...
    }
    
    // 正确做法:让异常向上抛出,或手动回滚
    @Transactional(rollbackFor = Exception.class)
    public void createOrderCorrect(Order order) throws BusinessException {
        // 先检查库存
        if (!inventoryService.checkStock(order.getProductId(), order.getQuantity())) {
            throw new BusinessException("库存不足");
        }
        
        // 保存订单
        orderRepository.save(order);
        
        // 扣减库存
        inventoryService.deductStock(order.getProductId(), order.getQuantity());
    }
}
```

**4. 过度依赖底层实现细节**

使用异常控制业务流程往往会过度依赖特定的异常类型:

```java
// 不推荐:依赖特定的数据库异常
public class ProductService {
    public Product saveProduct(Product product) {
        try {
            // 尝试保存商品
            return productRepository.save(product);
        } catch (DataIntegrityViolationException e) {
            // 依赖 Spring Data 的特定异常
            if (e.getCause() instanceof ConstraintViolationException) {
                // 进一步依赖具体的数据库异常
                return productRepository.findByCode(product.getCode());
            }
            throw e;
        }
    }
}

// 推荐:先检查再操作
public class ProductService {
    public Product saveProduct(Product product) {
        // 先查询是否存在
        Product existing = productRepository.findByCode(product.getCode());
        if (existing != null) {
            // 已存在,返回现有数据
            return existing;
        }
        
        // 不存在,执行保存
        return productRepository.save(product);
    }
}
```

**带来的风险**:
- 框架或数据库版本升级可能改变异常类型
- 不同的数据库可能抛出不同的异常
- 代码的可移植性变差
- 单元测试难以编写和维护

**5. API 设计不清晰**

良好的 API 设计应该明确表达意图,而使用异常控制流程会模糊 API 的真正用途:

```java
// 不好的 API 设计
public class CacheService {
    /**
     * 获取缓存数据
     * 注意:如果缓存不存在会抛出 CacheNotFoundException
     */
    public String get(String key) throws CacheNotFoundException {
        String value = cache.get(key);
        if (value == null) {
            throw new CacheNotFoundException("Key not found: " + key);
        }
        return value;
    }
}

// 使用方不得不用异常控制流程
public class UserService {
    public String getUserName(Long userId) {
        try {
            return cacheService.get("user:" + userId);
        } catch (CacheNotFoundException e) {
            // 缓存未命中是正常情况,不应该用异常表示
            return loadFromDatabase(userId);
        }
    }
}

// 好的 API 设计
public class CacheService {
    /**
     * 获取缓存数据
     * @return 缓存值,如果不存在返回 null
     */
    public String get(String key) {
        return cache.get(key);
    }
    
    /**
     * 获取缓存数据,如果不存在则执行加载函数
     */
    public String getOrLoad(String key, Supplier<String> loader) {
        String value = cache.get(key);
        if (value == null) {
            value = loader.get();
            cache.put(key, value);
        }
        return value;
    }
}

// 使用方代码更清晰
public class UserService {
    public String getUserName(Long userId) {
        return cacheService.getOrLoad(
            "user:" + userId,
            () -> loadFromDatabase(userId)
        );
    }
}
```

#### 正确使用异常的原则

```java
// 1. 异常应该表示真正的错误情况
public class FileService {
    public String readFile(String path) throws IOException {
        // IOException 表示文件不存在或读取失败,这是真正的错误
        return Files.readString(Paths.get(path));
    }
}

// 2. 正常的业务分支应该用返回值或条件判断
public class LoginService {
    public LoginResult login(String username, String password) {
        // 用户不存在是正常的业务情况,不应该抛异常
        User user = userRepository.findByUsername(username);
        if (user == null) {
            return LoginResult.failure("用户不存在");
        }
        
        // 密码错误也是正常的业务情况
        if (!passwordEncoder.matches(password, user.getPassword())) {
            return LoginResult.failure("密码错误");
        }
        
        return LoginResult.success(user);
    }
}

// 3. 使用 Optional 处理可能为空的情况
public class UserService {
    public Optional<User> findById(Long id) {
        return Optional.ofNullable(userRepository.findById(id));
    }
    
    // 使用时
    public void processUser(Long userId) {
        findById(userId)
            .ifPresentOrElse(
                user -> System.out.println("找到用户: " + user.getName()),
                () -> System.out.println("用户不存在")
            );
    }
}

// 4. 业务异常应该明确且有意义
public class PaymentService {
    public void pay(Order order) throws InsufficientBalanceException, PaymentTimeoutException {
        Account account = accountRepository.findById(order.getAccountId());
        
        // 余额不足是业务异常,但这是预期的错误情况
        if (account.getBalance() < order.getAmount()) {
            throw new InsufficientBalanceException(
                String.format("余额不足,当前余额: %.2f,需要: %.2f",
                    account.getBalance(), order.getAmount())
            );
        }
        
        // 执行支付...
    }
}
```

#### 总结

**异常应该用于表示异常情况,而不是控制正常的程序流程。**

记住以下几点:
1. **性能考虑**:异常的创建和处理代价高昂,不适合高频场景
2. **语义明确**:异常应该表示非预期的错误,不应该用于正常业务逻辑
3. **事务安全**:捕获异常可能影响事务回滚,导致数据不一致
4. **降低耦合**:避免过度依赖特定的异常类型和底层实现
5. **API 设计**:清晰的 API 应该通过返回值或方法名表达意图,而不是强制调用者处理异常

合理的做法是:
- **预期的情况**:使用返回值、Optional、条件判断
- **非预期的错误**:使用异常机制
- **业务校验**:先检查后操作,而不是先操作后捕获异常

## 反射机制

### 什么是反射?

反射是 Java 提供的一种机制,允许程序在运行时动态获取类的信息并操作类或对象。

```java
// 正常方式:编译时确定类型
Student student = new Student();
student.setName("张三");
String name = student.getName();

// 反射方式:运行时动态操作
Class<?> clazz = Class.forName("com.example.Student");
Object obj = clazz.newInstance();
Method setName = clazz.getMethod("setName", String.class);
setName.invoke(obj, "张三");
Method getName = clazz.getMethod("getName");
String name = (String) getName.invoke(obj);
```

### 反射的优缺点

**优点**:
1. **灵活性**:运行时动态加载类、创建对象
2. **框架基础**:Spring IoC、MyBatis ORM 等都基于反射
3. **解耦合**:降低模块间依赖

**缺点**:
1. **性能开销**:比直接调用慢 10-100 倍
2. **安全问题**:可以破坏封装,访问 private 成员
3. **代码可读性差**:复杂难理解,错误运行时才发现

```java
// 性能测试
public class ReflectionPerformance {
    public static void main(String[] args) {
        int count = 10000000;
        
        // 直接调用
        long start = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            User user = new User();
            user.setName("张三");
        }
        System.out.println("直接调用:" + (System.currentTimeMillis() - start) + "ms");
        
        // 反射调用
        start = System.currentTimeMillis();
        try {
            Class<?> clazz = User.class;
            Method setName = clazz.getMethod("setName", String.class);
            for (int i = 0; i < count; i++) {
                Object obj = clazz.newInstance();
                setName.invoke(obj, "张三");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("反射调用:" + (System.currentTimeMillis() - start) + "ms");
    }
}
```

### 反射的应用场景

**1. 依赖注入(Spring IoC)**
```java
@Component
public class UserService {
    @Autowired  // Spring 通过反射注入 UserRepository
    private UserRepository userRepository;
}
```

**2. 注解处理**
```java
// Spring 扫描 @Controller 注解
for (Class<?> clazz : classes) {
    if (clazz.isAnnotationPresent(Controller.class)) {
        // 通过反射创建实例并注册到容器
        Object controller = clazz.newInstance();
        registerController(controller);
    }
}
```

**3. 动态代理(AOP)**
```java
public class ProxyHandler implements InvocationHandler {
    private Object target;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("方法执行前");
        Object result = method.invoke(target, args);  // 反射调用
        System.out.println("方法执行后");
        return result;
    }
}
```

**4. ORM 框架(MyBatis/Hibernate)**
```java
// MyBatis 将查询结果映射为对象
ResultSet rs = statement.executeQuery("SELECT * FROM user WHERE id = 1");
User user = new User();
for (Field field : User.class.getDeclaredFields()) {
    field.setAccessible(true);
    field.set(user, rs.getObject(field.getName()));
}
```

## 注解详解

### 什么是注解?

注解(Annotation)是 JDK 5 引入的特殊的"标签",用于为程序元素添加元数据。

```java
// 注解的定义
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "";
    int priority() default 0;
}

// 注解的使用
public class Demo {
    @MyAnnotation(value = "test", priority = 1)
    public void method() {
        // ...
    }
}
```

**注解本质**:继承了 Annotation 接口
```java
public interface MyAnnotation extends Annotation {
    String value();
    int priority();
}
```

### 注解的解析方式

**1. 编译期扫描**
```java
@Override  // 编译器检查是否重写父类方法
public String toString() {
    return "Demo";
}

@SuppressWarnings("unchecked")  // 编译器忽略警告
List list = new ArrayList();
```

**2. 运行时反射处理**
```java
// Spring 扫描 @Component 注解
public class ComponentScanner {
    public void scan(String basePackage) throws Exception {
        // 扫描指定包下的所有类
        for (Class<?> clazz : getClasses(basePackage)) {
            if (clazz.isAnnotationPresent(Component.class)) {
                Component component = clazz.getAnnotation(Component.class);
                String beanName = component.value();
                // 创建实例并注册到 Spring 容器
                Object bean = clazz.newInstance();
                registerBean(beanName, bean);
            }
        }
    }
}
```

## SPI 机制

### 什么是 SPI?

SPI(Service Provider Interface)是 Java 提供的服务发现机制,允许第三方为系统提供实现。

```mermaid
graph TB
    subgraph "调用方"
        App([应用程序])
        Interface([服务接口])
    end
    
    subgraph "SPI 机制"
        ServiceLoader([ServiceLoader])
        Config([META-INF/services 配置])
    end
    
    subgraph "服务提供方"
        Impl1([实现 1])
        Impl2([实现 2])
        Impl3([实现 3])
    end
    
    App --> Interface
    Interface --> ServiceLoader
    ServiceLoader --> Config
    Config --> Impl1
    Config --> Impl2
    Config --> Impl3
    
    classDef appStyle fill:#4A90E2,stroke:none,color:#fff
    classDef spiStyle fill:#9B59B6,stroke:none,color:#fff
    classDef implStyle fill:#50C878,stroke:none,color:#fff
    
    class App,Interface appStyle
    class ServiceLoader,Config spiStyle
    class Impl1,Impl2,Impl3 implStyle
```

### SPI 与 API 的区别

```mermaid
graph TB
    subgraph "API 模式"
        API1([调用方]) --> API2([接口])
        API2 --> API3([实现])
        API3 -.->|服务提供方包含| API2
    end
    
    subgraph "SPI 模式"
        SPI1([调用方]) --> SPI2([接口])
        SPI3([实现1]) -.->|第三方实现| SPI2
        SPI4([实现2]) -.->|第三方实现| SPI2
        SPI2 -.->|调用方定义| SPI1
    end
    
    classDef callerStyle fill:#4A90E2,stroke:none,color:#fff
    classDef interfaceStyle fill:#9B59B6,stroke:none,color:#fff
    classDef implStyle fill:#50C878,stroke:none,color:#fff
    
    class API1,SPI1 callerStyle
    class API2,SPI2 interfaceStyle
    class API3,SPI3,SPI4 implStyle
```

- **API**:接口和实现都在服务提供方,调用方直接使用
- **SPI**:接口在调用方,实现由第三方提供

```java
// API 示例:JDBC 调用 MySQL 驱动
Connection conn = DriverManager.getConnection(url, user, password);

// SPI 示例:JDBC 接口由 MySQL、Oracle 等厂商实现
// java.sql.Driver 接口由 MySQL 实现为 com.mysql.cj.jdbc.Driver
```

### SPI 的优缺点

**优点**:
- 高度解耦
- 插件化扩展
- 灵活替换实现

**缺点**:
- 需要遍历加载所有实现,不能按需加载
- 多个 ServiceLoader 并发加载有并发问题

## 序列化与反序列化

### 基本概念

- **序列化**:将对象转换为字节流,便于存储或传输
- **反序列化**:将字节流转换回对象

```mermaid
graph LR
    A([Java 对象]) -->|Serialization 序列化| B([字节流])
    B -->|存储| C([文件/数据库])
    B -->|传输| D([网络])
    C -->|Deserialization 反序列化| E([Java 对象])
    D -->|Deserialization 反序列化| E
    
    classDef objStyle fill:#4A90E2,stroke:none,color:#fff
    classDef byteStyle fill:#E85D75,stroke:none,color:#fff
    classDef storageStyle fill:#50C878,stroke:none,color:#fff
    
    class A,E objStyle
    class B byteStyle
    class C,D storageStyle
```

**应用场景**:
- 网络传输(如 RPC)
- 数据持久化(文件/数据库/缓存)
- 深拷贝

### transient 关键字

阻止某个属性被序列化:

```java
public class User implements Serializable {
    private String username;
    private transient String password;  // 不会被序列化
    
    // 反序列化时 password 为 null
}
```

**注意**:
- `static` 变量不会被序列化(属于类而非对象)
- `transient` 只能修饰变量,不能修饰类和方法

### 常见序列化协议

| 协议 | 类型 | 优点 | 缺点 |
|------|------|------|------|
| JDK | 二进制 | 自带,无需依赖 | 性能差,体积大 |
| JSON | 文本 | 可读性好,跨语言 | 性能一般,体积较大 |
| Protobuf | 二进制 | 性能高,体积小 | 需要定义 .proto 文件 |
| Hessian | 二进制 | 性能好,体积小 | 官方 Java 库久未更新 |
| Kryo | 二进制 | 性能很好,体积小 | 不支持跨语言 |

## I/O 流

### I/O 流的分类

```mermaid
graph TB
    IO([Java I/O 流])
    
    IO --> Input([输入流])
    IO --> Output([输出流])
    
    Input --> ByteInput([字节输入流<br/>InputStream])
    Input --> CharInput([字符输入流<br/>Reader])
    
    Output --> ByteOutput([字节输出流<br/>OutputStream])
    Output --> CharOutput([字符输出流<br/>Writer])
    
    ByteInput --> FileInput([FileInputStream])
    ByteInput --> BufferInput([BufferedInputStream])
    ByteInput --> DataInput([DataInputStream])
    
    CharInput --> FileReader([FileReader])
    CharInput --> BufferedReader([BufferedReader])
    
    ByteOutput --> FileOutput([FileOutputStream])
    ByteOutput --> BufferOutput([BufferedOutputStream])
    ByteOutput --> DataOutput([DataOutputStream])
    
    CharOutput --> FileWriter([FileWriter])
    CharOutput --> BufferedWriter([BufferedWriter])
    
    classDef rootStyle fill:#4A90E2,stroke:none,color:#fff
    classDef directionStyle fill:#9B59B6,stroke:none,color:#fff
    classDef streamStyle fill:#3498DB,stroke:none,color:#fff
    classDef implStyle fill:#50C878,stroke:none,color:#fff
    
    class IO rootStyle
    class Input,Output directionStyle
    class ByteInput,CharInput,ByteOutput,CharOutput streamStyle
    class FileInput,BufferInput,DataInput,FileReader,BufferedReader implStyle
    class FileOutput,BufferOutput,DataOutput,FileWriter,BufferedWriter implStyle
```

### 字节流 vs 字符流

**字节流**:处理二进制数据
```java
// 读取图片
FileInputStream fis = new FileInputStream("image.jpg");
int data;
while ((data = fis.read()) != -1) {
    // 处理字节
}
fis.close();
```

**字符流**:处理文本数据,自动处理编码
```java
// 读取文本
FileReader fr = new FileReader("text.txt");
int data;
while ((data = fr.read()) != -1) {
    // 处理字符
}
fr.close();
```

### BIO、NIO 和 AIO

| 模型 | 描述 | 特点 |
|------|------|------|
| BIO | Blocking I/O,阻塞 I/O | 一个连接一个线程 |
| NIO | Non-blocking I/O,非阻塞 I/O | 一个线程处理多个连接 |
| AIO | Asynchronous I/O,异步 I/O | 异步非阻塞,基于事件回调 |

## 语法糖

### 什么是语法糖?

语法糖是编程语言为了方便程序员开发而设计的特殊语法,本质上是编译器的优化。

```java
// for-each 语法糖
for (String item : list) {
    System.out.println(item);
}

// 编译后的实际代码
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    System.out.println(item);
}
```

### Java 常见语法糖

1. **泛型**:编译后擦除
2. **自动装箱拆箱**:valueOf()/xxxValue()
3. **变长参数**:数组
4. **枚举**:继承 Enum 类
5. **内部类**:生成独立的 class 文件
6. **增强 for 循环**:Iterator
7. **try-with-resources**:自动 close()
8. **Lambda 表达式**:InvokeDynamic 指令
9. **字符串拼接**:StringBuilder
