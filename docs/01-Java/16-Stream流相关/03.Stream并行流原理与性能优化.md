---
slug: /java/stream/parallel-stream
sidebar_class_name: has-paid-badge
---

import PaidCTA from '@site/src/components/PaidCTA';

# Stream并行流原理与性能优化

## 并行流概述

Java 8的Stream API不仅提供了便捷的数据处理方式，还内置了并行处理能力。通过并行流（Parallel Stream），开发者可以轻松利用多核CPU的计算能力，无需手动管理线程。

```java
public class DataAnalyzer {
    public void analyze() {
        List<SalesRecord> records = getSalesRecords();
        
        // 串行流处理
        Stream<SalesRecord> serialStream = records.stream();
        
        // 并行流处理
        Stream<SalesRecord> parallelStream = records.parallelStream();
        
        // 串行流转并行流
        Stream<SalesRecord> converted = records.stream().parallel();
    }
}
```

## Fork/Join框架实现原理

并行流底层基于Java 7引入的**Fork/Join框架**实现。该框架采用分治策略：将大任务递归拆分为小任务，分配到多个线程并行执行，最后合并结果。

```mermaid
flowchart TB
    subgraph Fork/Join执行模型
        A[原始任务] --> B{任务可拆分?}
        B -->|是| C[Fork拆分]
        C --> D[子任务1]
        C --> E[子任务2]
        D --> F{可继续拆分?}
        E --> G{可继续拆分?}
        F -->|否| H[执行计算]
        G -->|否| I[执行计算]
        H --> J[Join合并]
        I --> J
        J --> K[最终结果]
        B -->|否| L[直接计算]
        L --> K
    end
    style A fill:#e3f2fd,stroke:#1565c0,rx:10,ry:10
    style C fill:#fff3e0,stroke:#ef6c00,rx:10,ry:10
    style J fill:#e8f5e9,stroke:#388e3c,rx:10,ry:10
    style K fill:#c8e6c9,stroke:#2e7d32,rx:10,ry:10
```

### 源码层面分析

以Stream的`reduce`操作为例，查看其内部实现（`ReferencePipeline`类）：

```java
@Override
public final Optional<P_OUT> reduce(BinaryOperator<P_OUT> accumulator) {
    return evaluate(ReduceOps.makeRef(accumulator));
}

final <R> R evaluate(TerminalOp<E_OUT, R> terminalOp) {
    if (linkedOrConsumed)
        throw new IllegalStateException("stream has already been operated upon or closed");
    linkedOrConsumed = true;
    
    // 根据是否并行流选择不同执行路径
    return isParallel()
           ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
           : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}
```

当`isParallel()`返回true时，执行`evaluateParallel`方法。不同的终端操作对应不同的Task实现：

```mermaid
flowchart LR
    subgraph 并行任务类型
        A[MatchTask] --> E[CountedCompleter]
        B[FindTask] --> E
        C[ReduceTask] --> E
        D[ForEachTask] --> E
        E --> F[ForkJoinTask]
        F --> G[ForkJoinPool执行]
    end
    style E fill:#f3e5f5,stroke:#7b1fa2,rx:10,ry:10
    style G fill:#e8f5e9,stroke:#388e3c,rx:10,ry:10
```

这些Task都继承自`CountedCompleter`，而`CountedCompleter`是`ForkJoinTask`的子类：

```java
public abstract class CountedCompleter<T> extends ForkJoinTask<T> {
    // 实现任务的拆分与合并逻辑
}
```

## 并行流性能分析

### 影响性能的关键因素

并行流并非总是比串行流更快，其性能受多种因素制约：

```mermaid
flowchart TB
    subgraph 性能影响因素
        A[线程管理开销] --> B[线程创建与切换成本]
        C[任务分割均衡性] --> D[任务大小不均导致等待]
        E[线程资源竞争] --> F[共享ForkJoinPool]
        G[数据依赖性] --> H[有状态操作无法并行]
        I[硬件配置] --> J[CPU核心数与负载]
    end
    style A fill:#ffebee,stroke:#c62828,rx:10,ry:10
    style C fill:#fff3e0,stroke:#ef6c00,rx:10,ry:10
    style E fill:#fce4ec,stroke:#ad1457,rx:10,ry:10
    style G fill:#e8eaf6,stroke:#3f51b5,rx:10,ry:10
    style I fill:#e0f2f1,stroke:#00796b,rx:10,ry:10
```

### 性能对比实验结论

根据不同场景下的性能测试，得出以下结论：

#### 场景一：多核CPU + 小数据量

<PaidCTA />